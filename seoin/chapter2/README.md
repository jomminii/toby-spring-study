### 2장 테스트(145p-207p)

스프링이 개발자에게 제공하는 가장 중요한 가치는 객체지향과 테스트다.

애플리케이션의 복잡도는 높아지고, 변화가 잦아진다.

→ 이 변화에 대응하기 위해 1) 확장에 유연한 객체지향적 설계가 중요하고 2) 대처할 수 있게 자신감을 주는 테스트 기술이 필요하다.

- 테스트란 개발자가 예상하고 의도했던 대로 코드가 정확히 동작하는지를 확인해 만든 코드를 확신할 수 있게 해주는 작업이다.

- **2.1 UserDaoTest 다시보기**
    - 기존 UserDaoTest
        - main() 메소드를 이용한 테스트 수행
        - 테스트 대상인 UserDao의 직접 호출
    - 기존 UserDaoTest의 문제점
        - **모든 레이어의 기능을 만들어야 테스트가 가능하다는** 큰 단점이 있다.
            - 테스트에 관여하는 클래스가 너무 많다 → 어디서 에러인지?
    - 작은 단위의 테스트로 쪼개야 한다 → 단위 테스트(Unit Test)
        - 테스트의 관심이 다르다면 테스트할 대상을 분리하고 집중해서 접근해야 한다.
        - 외부 리소스에 의존하는 테스트는 단위 테스트라고 보기 어렵다.
        - 단위 테스트는 코드가 의도한 대로 동작하는지 빠르게 확인하기 위해서다.
    - 테스트는 자동으로 수행될 수 있어야 한다. (자주 반복하기 위해)

- **2.2 UserDaoTest 개선**
    - 문제점
        - 현재 단순히 테스트 결과를 출력하고 있음 → 테스트 검증의 자동화 필요
        - main() 메소드로 확인 → 규모가 커지면 부담 증가
    - JUnit 테스트로 전환
        - 테스트 프레임워크를 이용하자
        - 가장 먼저 할 일은 main() 메소드에 있던 테스트 코드를 일반 메소드로 옮기는 것
        - 2가지 조건이 있는데,
            - 1) 메소드가 public으로 선언되어야 하는 것
            - 2) 메소드에 `@Test` 어노테이션을 붙여주는 것
        - assertThat() 메소드로 첫 번째 매개변수의 값을 뒤에 오는 matcher 조건으로 비교해 일치하는지 확인한다.

- **2.3 개발자를 위한 테스팅 프레임워크 JUnit**
    - 테스트하기 전에 테스트 실행에 문제가 되지 않는 상태를 만들어주는 편이 낫다.
    - 단위 테스트는 항상 일관성 있는 결과가 보장돼야 한다.
        - DB에 남아있는 데이터와 같은 외부 환경에 영향을 받지 말아야 하며,
        - 테스트를 실행하는 순서에도 영향을 받지 않고 동일한 결과가 보장되어야 한다.
    - JUnit은 특정 테스트 메소드의 실행 순서를 보장해주지 않는다.
        - 테스트의 결과가 실행 순서에 영향을 받는다면 테스트를 잘못 만든 것이다.
        - 모든 테스트는 실행 순서에 상관없이 독립적으로 항상 동일한 결과를 내야 한다.
    - 예외 조건에 대한 테스트
        - ID 값이 나오지 않는다면 어떻게 해야 할까?
            - null 같은 특별한 값을 리턴하게 하거나,
            - exception을 던지자(ex) EmptyResultDataAccessException)
    - 개발자가 자주 하는 실수 중 하나가, 성공하는 테스트만 골라서 만드는 것이다.
        - 다양한 상황과 입력 값을 고려해 포괄적인 테스트를 만들 수 있다.
        - **항상 네거티브 테스트를 먼저 만들어야 한다.**
    - JUnit이 하나의 테스트 클래스를 수행하는 방식
        1. 테스트 클래스에서 `@Test` 가 붙은 public이고 void형이며 파라미터가 없는 테스트 메소드를 모두 찾는다.
        2. 테스트 클래스의 오브젝트를 하나 만든다.
        3. `@Before` 가 붙은 메소드가 있으면 실행한다.
        4. `@Test` 가 붙은 메소드를 하나 호출하고 테스트 결과를 저장해둔다.
        5. `@After` 가 붙은 메소드가 있으면 실행한다.
        6. 나머지 테스트 메소드에 대해 2~5번을 반복한다.
        7. 모든 테스트의 결과를 종합해서 돌려준다.
    - 각 테스트 메소드를 실행할 때마다 테스트 클래스의 오브젝트를 새로 만든다.
        - 한 번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고 나면 버려진다.
            - 왜 이렇게 할까?
                - 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 확실히 보장하기 위해 매번 새로운 오브젝트를 만들게 함
                - 어차피 다음 테스트 메소드가 실행되면 새로운 오브젝트가 만들어져서 다 초기화 될 것
    - 픽스처(fixture)
        - 테스트를 수행하는데 필요한 정보나 오브젝트(보통 `@Before` 에 setup으로 들어가는 데이터들)
    
- **2.4 스프링 테스트 적용**
    - 애플리케이션 컨텍스트에서의 고민점
        - `@Before` 가 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트도 그 개수만큼 생성된다.
            - 빈에 따라 초기화 작업이 오래걸리는 것들이 있을 수 있음
            - 어떤 빈은 독자적으로 너무 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 함 → 이런 경우, 애플리케이션 컨텍스트 내의 빈이 할당한 리소스 등을 깔끔하게 정리해주지 않으면 다음 테스트에서 새로운 애플리케이션 컨텍스트가 만들어지면서 문제를 일으킬 수 있다.
        - 테스트가 가능한 한 독립적으로 매번 새로운 오브젝트를 만들어야 하는 것은 맞으나, 애플리케이션 컨텍스트처럼 생성에 많은 시간과 자원이 소모되는 경우 테스트 전체가 공유하는 오브젝트를 만들기도 한다. → 1번만 만들고, 여러 테스트에서 공유해서 씀
    - 테스트 컨텍스트 프레임워크를 쓰자
        - 테스트 클래스 간 컨텍스트를 공유하자
        - 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다. 애플리케이션 컨텍스트에는 ApplicationContext 타입의 빈이 존재하고 DI도 가능하다.
    - 굳이 인터페이스를 쓰고, DI를 통해 주입해줘야 하는 이유
        - 바뀌지 않는 것은 없다
        - 구현 방식이 바뀌지 않더라도 DI를 해두면 다른 차원의 서비스 기능 도입이 가능함
        - 테스트가 쉬워진다
    - 테스트 코드에 의한 DI
        - **스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자**
            - 가장 빠르고, 간결함
        - 그 다음 의존관계가 있는 오브젝트를 테스트 할 때, 스프링 설정을 이용한 DI 방식의 테스트를 이용하자.
        - 테스트 설정이 있더라도 예외적인 의존관계를 강제로 구성해서 테스트해야 하는 경우, 수동 DI를 고려하자.
    
- **2.5 학습 테스트로 배우는 스프링**
    - 다양한 조건에 따른 기능을 손쉽게 확인 가능
    - 개발 중에 참고 가능
    - 프레임워크나 제품을 업그레이드할 때 호환성 검증에 도움
    - 테스트 작성에 대한 좋은 훈련
    - 새로운 기술 공부 과정에 도움
    
    - 버그 테스트 : 코드에 오류가 있을 때 그 오류를 가장 잘 드러내줄 수 있는 테스트
        - 테스트의 완성도를 높여줌
        - 버그의 내용을 명확히 분석하게 해줌
        - ㄱ술적인 문제 해결에 도움을 줌