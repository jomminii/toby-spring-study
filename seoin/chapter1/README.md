### 1장 오브젝트와 의존관계(53p-143p)



스프링이 가장 관심 두는 대상은 **오브젝트다**.


- **1.1 초난감 DAO**
    - 자바빈
        - 파라미터 없는 디폴트 생성자 필요(리플렉션을 이용해 오브젝트 생성 목적)
        - 프로퍼티(getter, setter)


- **1.2 DAO의 분리**
    - 관심사의 분리(Separation of Concerns)
        - 변화는 대체로 집중된 한 가지 관심에 대해 일어나지만 그에 따른 작업은 한 곳에 집중되지 않는 경우가 많다. → 관심이 한 군데에 집중되게 하자!
    - 예시
        - UserDao의 관심사항
            1. DB Connection - 어떤 DB, Driver, login 정보, 생성 방법 (…)
            2. DB Query 실행
            3. 사용한 리소스(Statement, Connection) 닫기
    - 리팩토링은 **기능엔 영향을 주지 않으면서 코드의 구조만 변경**
    - 템플릿 메소드 패턴(template method pattern)
        - 슈퍼클래스에 기본적인 로직의 흐름을 만들고(변하지 않는 기능), 그 기능의 일부를 추상 메소드나 오버라이딩이 가능한 protected 메소드 등으로 만든 후,
        - 서브 클래스에서 이런 메소드를 필요에 맞게 구현해서 사용하게 하는 방법(자주 변경되거나 확장할 기능은 서브클래스에 만듦)
        
        ```kotlin
        public abstract class Super {
        	public void templateMethod() {
        		hookMethod();
        		abstractMethod();
        ```
        
    - 팩토리 메소드 패턴(factory method pattern)
        - 서브클래스에서 구체적인 오브젝트 생성 방법을 결정
    - 상속의 문제
        - 자바는 다중 상속이 허용되지 않아 다른 목적으로 상속 적용이 힘듬
        - 상속을 이용하면 상하위 클래스의 관계가 생각보다 밀접함


- **1.3 DAO의 확장**
    - 관심이 다름 == 변화의 성격이 다름
    - **근본적인 문제는** 해당 클래스가 `바뀔 수 있는 정보` 를(DB Connection Class) 너무 많이 알고 있기 때문이다.
    - 인터페이스를 이용해 추상화해 구체적인 정보를 모두 감추자.
    - 클래스(UserDao)와 해당 클래스가 사용할 클래스(ConnectionMaker)의 특정 구현 클래스 사이의 관계를 설정해주는 것에 관한 관심 → 여기서는 ‘사용'의 관계
        - **책임을 클라이언트로 떠넘기자** → 생성자 파라미터에 사용할 구현된 오브젝트를 설정
    - OCP(Open-Closed Principle)
        - 클래스나 모듈은 확장에 열려 있어야 하고 변경에는 닫혀 있어야 함
    - 높은 응집도
        - 하나의 모듈, 클래스가 하나의 책임 또는 관심사만 집중함
        - 변화가 일어날 때 해당 모듈에서 변하는 부분이 큼
    - 낮은 결합도
        - 하나의 변경이 발생할 때 다른 모듈, 객체로 변경에 대한 요구가 전파되지 않게 함
    - 전략 패턴(strategy pattern)
        - context에 따라 변경이 클래스를 인터페이스로 분리 + 구현한 클래스를 사용
        - 클라이언트는 context가 사용할 전략을 context의 생성자 등을 통해 제공함


- **1.4 제어의 역전(IoC)**
    - 일반적인 프로그램 흐름
        - 프로그램 시작 → 사용할 오브젝트 결정 → 결정한 오브젝트 생성 → 생성된 오브젝트의 메소드 호출 → 오브젝트 메소드 안에서 다음에 사용할 것을 결정(반복)
        - 오브젝트가 자신이 사용할 클래스를 결정, 언제, 어떻게 만들지 결정하고 제어
    - 제어의 역전
        - 오브젝트가 자신이 사용할 오브젝트를 스스로 선택, 생성하지 않음
        - 특별한 오브젝트가 특별 권한을 갖고 의해 결정되고 생성함
        - 예시)
            - 서블릿 → 서블릿에 대한 제어 권한을 가진 컨테이너가 적절한 시점에 서블릿 클래스의 오브젝트를 만들고 그 안의 메서드 호출
            - 템플릿 메소드 패턴 → 슈퍼클래스에서 템플릿 메소드를 호출하면 하위 클래스가 호출되어 사용됨
            - 프레임워크 → 애플리케이션 코드가 프레임워크에 의해 사용됨
        - 설계 깔끔 + 유연성 증가 + 확장성 좋아짐


- **1. 5 스프링의 IoC**
    - Bean : 스프링이 제어권을 갖고 직접 만들고 관계를 부여하는 오브젝트(IoC 적용된 오브젝트)
    - Bean Factory : 빈의 생성, 관계설정 같은 제어를 담당하는 IoC 오브젝트
    - Application Context : IoC 방식을 따라 만들어진 일종의 Bean Factory(확장 느낌)
        - Application Context는 Bean Factory 인터페이스를 상속함
        - 스프링의 가장 대표적인 오브젝트
        - 동작 방식
            - 오브젝트에 대한 생성, 관계설정을 담당 → 정보는 config에서 얻음
            - config 에 클래스를 등록해두고 `@Bean`이 붙은 메소드 이름을 가져와 Bean 목록을 만들어 둔다. 메소드가 호출되면 그 목록에서 찾고 빈을 생성하는 메소드를 호출해 오브젝트를 생성시킨 후 클라이언트에 반환함
        - 장점
            - 클라이언트는 구체적인 팩토리 클래스를 몰라도 된다
            - 여러 IoC 서비스를 제공함 - 자동생성, 후처리, 정보 조합, 인터셉팅 등
            - Bean 검색이 다양함


- **1.6 싱글톤 레지스트리와 오브젝트 스코프**
    - ** 동일성(비교, ==), 동등성(비교, equals)
    - Application Context는 IoC 컨테이너인 동시에 Singleton Registry임
        - Singleton Registry : 싱글톤을 저장하과 관리함
        - 별다른 설정을 하지 않으면 기본적으로 내부 생성하는 빈 오브젝트를 모두 싱글톤으로 만듦
        - 왜 ? → 스프링이 주로 적용되는 대상이 서버 환경임. 즉, 여러 요청을 빠르게 처리해야 하는 성능이 요구되는 환경. 클라이언트에서 매번 요청이 올 때마다 각 로직을 담당하는 오브젝트를 새로 생성하면 부하가 걸리기 쉬움
        - 애플리케이션 안에 제한된 수, 대개 한 개의 오브젝트만 만들어 사용하는게 싱글톤 원리. 서버 환경에서 서비스 싱글톤 사용이 권장된다.
    - 싱글톤 패턴의 한계
        - private 생성자를 갖고 있어 상속 불가
        - 테스트하기 힘듦
        - 서버 환경에서 싱글톤이 하나만 만들어지는 걸 보장하지 못함
        - 전역 상태를 만들 수 있어 바람직 하지 못함
    - Singleton Registry
        - 스프링이 직접 싱글톤 형태의 오브젝트를 만들과 관리하는 기능(생성, 관리, 공급)
        - 싱글톤 방식으로 사용될 클래스도 public 생성자를 가질 수 있게 됨
        - 테스트 환경에서 자유롭게 오브젝트를 만들 수 있고, 테스트를 위한 Mock Object를 대체하는 것도 간단함. 생성자 파라미터를 이용해 사용할 오브젝트를 넣어줄 수 있음.
        - 객체 지향, 디자인 패턴을 적용하는데 제약이 없어짐
    - 주의할 점
        - 멀티스레드 환경에서 state 관리가 중요 → 최대한 stateless하게 가져가야함
        - 메소드 파라미터, 로컬 변수 등은 다른 메모리를 사용하므로 여러 스레드가 사용해도 값을 덮어쓸 일이 없음
    - Bean Scope : 빈이 생성되고, 존재하고, 적용되는 범위. 기본 스코프는 싱글톤.
        - Prototype Scope : 빈을 요청할 때마다 매번 새로운 오브젝트를 만들어줌
        - HTTP Scope : Request Scope, Session Scope


- **1.7 의존관계 주입(DI)**
    - DI(Dependency Injection) : Spring IoC의 대표적인 동작원리는 주로 이 DI라고 함
        - 의존관계 설정
        - 스프링을 IoC 컨테이너 대신 DI 컨테이너라고 함
    - 런타임시 의존관계를 맺는 대상 → Dependent Object
    - 의존관계 주입은(설정은) 아래 3가지를 충족해야 함
        - 클래스 모델이나 코드에는 런타임 시점의 의존관계가 드러나지 않음. 인터페이스에만 의존
        - 런타임 시점의 의존관계는 컨테이너나 팩토리 같은 제3의 존재가 결정
        - 의존관계는 사용할 오브젝트에 대한 레퍼런스를 외부에서 제공해줌으로써 만듦
    - 의존관계 검색(Dependency Lookup)
        - 자신이 필요한 의존 오브젝트를 능동적으로 찾음
        - 어떤 클래스의 오브젝트를 이용할지 결정하지 않음, 가져올 때는 컨테이너에 요청함
        - 의존관계 주입은 Bean으로 등록되어 있어야 하나, 검색은 그러지 않아도 됨
    - 장점
        - 기능 구현의 교환 용이
        - 부가기능 추가 쉬움
    - 메소드를 이용한 의존관계 주입(생성자 대신)
        - 수정자(setter) 메소드를 이용한 주입
        - 일반 메소드를 이용한 주입


- **1.8 XML을 이용한 설정**
    - 생략


- **1.9 정리**
    - **관심사의 분리**, **리팩토링**
    - **바뀔 수 있는** 클래스는 인터페이스를 구현하도록 하기
    다른 클래스는 인터페이스를 통해서만 접근 가능
    - 개방 폐쇄 원칙 : 자신의 책임이 변경되는 경우 외에는 다른 클래스의 변화에 의해 불필요한 변화가 발생하지 않고, 자유롭게 자신을 확장 / 변경할 수 있음
    - 별도의 오브젝트 팩토리를 만들어 오브젝트 생성/관리 권한을 넘김. 
    오브젝트 팩토리의 기능을 **일반화**한 IoC 컨테이너로 넘김.(IoC)
    - 싱글톤 레지스트리 - 싱글톤 패턴의 단점을 극복할 수 있도록 설계된 컨테이너를 활용
    - 설계 시점과 코드에는 클래스와 인터페이스 사이의 느슨한 의존관계만 만들어 놓고, 
    **런타임시** **주입** 받아서 다이내믹한 의존관계를 갖게 해주는 IoC의 특별한 케이스(DI)