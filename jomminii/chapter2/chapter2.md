# [토프링] 2장 테스트
[[토프링] 2장 테스트 - 기존 테스트 다시보기](https://velog.io/@jomminii/toby-spring-chapter02-01)
[[토프링] 2장 테스트 - 그 외 개념들](https://velog.io/@jomminii/toby-spring-chapter02-02)

>토비의 스프링 스터디를 진행하며 작성한 글 입니다. 대부분 토비의 스프링을 참조하고 있습니다.
- [스터디 github](https://github.com/jomminii/toby-spring-study)
- [샘플 코드](https://github.com/jomminii/toby-spring-sample-code)

<br>

테스트란 무엇일까.

이전 팀에 있었을 때는 테스트를 작성하는 문화가 없었어서 테스트의 중요성을 잘 느끼진 못했다. 느끼지 못했다라기 보다는 느끼곤 있었지만 이게 테스트가 없어서 라는걸 알아채지 못했던 것 같다.

뭔가 개발 트렌드를 보면 TDD니 뭐니 하면서 `테스트를 무조건 해야해!!!` 라고 외치고 있었지만 정작 팀에서는 안하다보니 `개발 시간을 더 잡아먹는 골치 아픈 프로세스` 라고 막연히 생각했었다.

그런데 지금 팀에서는 뭐 아주 바쁠때는 테스트를 잠시 뒤로 미루긴 하지만 건너뛰진 않는다. 커버리지를 100%까지 채우긴 힘들지만 되도록 커버리지를 높이려고 노력하고 있다.

개발을 하면서 테스트를 작성하면서 늘어가는게 하나 있는데,

>**수정에 대한 자신감 !**

수정을 안하면 좋겠지만 리팩토링이든 요건 변경이든 이런저런 이유로 이미 레거시가 되어버린 코드를 수정하게 되는데, 이젠 테스트만 돌리면 되니 안도감이 생긴다.

특히 다른 사람이 짠 코드와 연관된 부분을 수정할 때 이 쾌감을 느끼게 되는데, 이전에는 테스트를 안짰기에 하나하나 손테스트를 했지만 이제는 전체 테스트만 한 번 실행해보면 된다.

**이 쾌감이란 !**

2장 테스트 서문에서도 이 말을 하고 싶었던 것 같다.
>만들어진 코드에 확신을 가질 수 있게 해주고 변화에 유연하게 대처할 수 있는 자신감을 주는 것이 테스트  !

라고 한다.

이제 본격적으로 스터디를 시작해보자.

<br>

# 2.1 1장에서 작성한 테스트 다시 보기

## TestMain의 특징

### 웹을 통한 DAO 테스트 방법의 문제점
이 부분은 잘 공감이 가지 않았는데 예전에 쓰여진 책이라 그런가...
보통 웹 프로그램에서 사용하는 DAO 를 테스트하는 방법으로 서비스 계층, MVC 프레젠테이션 계층, DAO 를 대충이라도 모두 만들고 화면까지 띄워서 값을 입력하고 버튼을 누르고...를 예시로 들었는데.

단위 테스트에 익숙해져서인지 통합테스트가 아닌 이상에야 이런 식의 테스트가 보통의 테스트라는게 공감이 가지 않았다.

이런 식으로 코드를 작성하게 되면 당연히도 내가 테스트 하고 싶은 부분 외에 발을 걸치고 있는 코드들이 너무나 많아서 원하는걸 테스트 하기 쉽지 않다.

에러가 발생해도 뭐 때문인지 확인하기 어렵고, 성공해도 정말 문제가 없어서 성공한건지 알기 쉽지 않다.

<br>

### 작은 단위의 테스트
#### 이런걸 단위 테스트라고 한다.

```java
public class TestMain {

    public static void main(String[] args) throws SQLException, ClassNotFoundException {
        UserDao dao = new UserDao();

        User user = new User();
        user.setId("testId");
        user.setName("테스트아이디");
        user.setPassword("password");

        dao.add(user);

        System.out.println(user.getId() + " 등록 성공");

        User user2 = dao.get(user.getId());
        System.out.println(user2.getName());
        System.out.println(user2.getPassword());
        System.out.println(user2.getId() + " 조회 성공");
    }
}
```

기존에 작성했던 1장의 테스트 코드를 한 번 살펴보자.

위에서 말했던 모든 계층을 다 거치는 테스트랑은 거리가 멀어보인다. 간단히 작성하긴 했지만 DB에 값을 등록하고 조회해오는 DB 관련 기능만 딱 집어서 테스트를 하고 있다.

**내가 테스트 하고 싶은 기능에만 집중해서 테스트 하는 것.**

이렇게 한 가지 관심에 집중할 수 있게 작은 단위로 만들어진 테스트를 단위 테스트라고 한다. 관심사의 분리라는 객체지향적 특징이 여기에도 반영된건데 이렇게 관심사를 분리하면 다른 기능이 어떻게 구현되었든 현혹되지 않고 원하는 기능이 잘 만들어졌는지만 효율적으로 파악할 수 있다.

간혹 DB 가 사용된 테스트는 단위 테스트라고 할 수 없다고 하는 개발자들도 있다고 하는데, 완전히 통제할 수 있는 DB 리소스를 사용하고 있다면 단위 테스트라고 볼 수 있다. 위의 `TestMain` 에서는 매 테스트마다 기존에 생성된 DB 데이터를 지워줘야하는데, 이 부분은 우리가 통제할 수 있기 때문에 단위 테스트가 될 수 있는 것이다.

만약 우리가 DB 를 통제할 수 없다면, 예를 들어 DB 에 값이 저장되었고 다시 테스트를 하기 위해 이 값에 수정이 필요하다고 해보자. 하지만 이 리소스에 대한 통제 권한이 없어서 테스트 진행에 영향을 주게 된다면 이는 단위 테스트라고 부를 수 없다.


#### 추가로 단위 테스트가 필요한 이유
단위 테스트 외에도 좀 더 긴 과정을 테스트 해야할 경우도 있을 것이다. 각각의 기능은 잘 작동해도 어떤 이유에선지 일련의 프로세스를 타면 안되는 경우도 많기 때문에 이런 테스트도 필요하다.

예를 들어 로그인 하고 특정 메뉴를 누르고 어떤 과정을 진행하고 DB 를 건드는 일련의 과정 같은걸 하나의 테스트로 진행할 수도 있다.

이때 만약 각각의 과정들을 단위 테스트로 작성해두었다면 중간에 어떤 에러가 발생해도 어디에서 문제가 발생했는지 보다 빠르게 확인할 수 있다.

그리고 개발자 입장에서도 자신이 설계해서 만든 코드가 자신의 의도대로 정상 작동하는지 빠르게 피드백을 받을 수 있다는 점에서도 단위 테스트는 필요하다. 그래서 단위 테스트를 개발자 테스트라고 부르기도 한다.

<br>


### 자동수행 테스트 코드
테스트는 자동으로 수행되도록 작성해야한다. 이것도 당연한 느낌이긴한데... 손으로 일일이 확인하는게 시간도 걸리고 정확성 면에서도 떨어지기 때문에 테스트를 작성하자는건데 자동으로 수행되도록 안짜면 말이 되나... 싶지만 일단 작성해본다.

손으로 테스트를 진행한다면 하나의 프로세스를 거치려고 해도 짧게는 몇초에서 길게는 몇 분까지 진행해야할 수도 있다. 게다가 테스트를 한 번만 하는 것도 아니고, 한 개만 하는 것도 아니니 이 지난한 과정을 지나치다가 실수가 일어날 수도 지칠 수도 있다.

하지만 자동으로 수행되도록 작성된다면 난 테스트 실행만 하면 되고 귀찮고 어렵고 지루한 과정은 컴퓨터가 대신해준다. 빠르고 정확한 결과물은 덤이다.

그리고 자주 반복할 수 있다는 것도 큰 장점이다. 내가 짠 코드가 레거시 코드들과 많은 연관관계가 있다면 이걸 손 테스트로 테스트하는건 아주 큰 문제가 될 수 있다.

하지만 우리에겐 자동 수행 테스트가 있으니 걱정하지 말자. 컴퓨터 시키면 된다.

### 지속적인 개선과 점진적인 개발을 위한 테스트
단위 테스트를 작성하고, 또 이 코드를 자동으로 수행되도록 작성했다.

이제 ** 우린 수정에 대한 자신감을 얻었다 !**

이 자신감으로 우리의 개발은 빨라질 것이고 시행착오는 적어질 것이며 ~~연봉은 올라갈 것이다.~~

<br>

## TestMain 의 문제점

당연하게도 지금의 `TestMain`에는 많은 문제가 존재한다.

#### 일단 우린 테스트를 한다고는 했지만 그 결과를 우리 눈으로 직접 확인하고 있다.
그냥 프린트만 찍어서 어떤 결과가 나왔는지만 확인하고 있다.

이러면 안된다. 지금이야 한 두개지만 나중에 수십 수백개의 테스트를 돌리면 어떻게 일일이 이 결과를 확인하고 있나.

결과에 대한 확인까지 테스트가 자동으로 수행하게 해야한다.


#### 실행이 번거롭다.
지금은 테스트를 실행하려면 `TestMain`의 `main()`을 직접 실행해줘야한다. 이것도 위의 이유와 마찬가지로 하나하나 언제 다 실행하고 있나.

테스트를 한 번에 실행할 수 있는 무언가가 필요하다.

<br>


<br>

2장의 기존 테스트 다시보기를 읽은 후 그 뒷 부분을 읽기 시작했는데, 토비님이 말씀하셨던 것처럼 좀 개괄적인 느낌이 강했다.

일부 개념들 소개를 간단히 하고, `junit` 기초 사용법을 설명해 주는 느낌 정도였다.

그래서 사용 예시는 사용할 때 바뀐 부분들을 알아보면서 하면 될거라 생각해서 굳이 정리하지 않고 키워드 몇 개만 좀 더 살펴보고 정리해 보려고 한다.

# TDD
타다다... 투드득...
아니다. Test Driven Development 테스트 주도 개발 방법론이다.

테스트라는걸 알게 되고 귀동냥을 하게 되면서 TDD 라는 방법론에 대해 조금씩 주워듣게 되었다.

주워듣기만 했을 뿐 주변에서는 이 방법론을 사용하는걸 본 적도 없었고 그냥 책에 있는 원론적인 내용이구나 생각했었다.

계속 들어오는 요건들이나 hotfix, 그리고 비즈니스 적인 상황이 변함에 따라 변하는 비즈니스 로직들... 이걸 다 쳐내기에도 우린 시간이 부족하다. 그래서 TDD 는 커녕 테스트를 작성하지 않기도 했다. (전 팀에서)

그런데 이제 테스트를 작성해가면서 테스트의 효용에 대해 피부로 느끼게 되고 TDD에도 눈길이 가게 되었다.

<br>

## 그래서 TDD가 뭔데
아직 TDD 책을 읽어보진 않아서 [[TDD] 단위 테스트와 TDD(테스트 주도 개발) 프로그래밍 방법 소개 - 망나니 개발자] (https://mangkyu.tistory.com/182) 를 읽어보고 정리해본다.

<br>

TDD 는 기존의 개발 순서를 거스르는 방법론이다. 기존에는 `설계` -> `비즈니스 로직 개발` -> `테스트 작성` 의 순서로 진행했다면 TDD 는 `설계` -> `테스트 작성` -> `비즈니스 로직 개발` 의 순서로 진행된다.

이게 가능한걸까.

구현한 비즈니스 로직을 테스트 하기 위한 로직을 짜는 것만도 테스트를 다 짤 수 있니 마니 하는데, 미리 테스트를 다 작성한다는게 말이 되는 이야긴가.

지금도 말이 안된다고 생각하긴 한다. 근데 지금도 커버리지 100%로 테스트를 작성하진 않으니 어느정도는 가능할 것도 같다.

<br>

### 왜 TDD 를 해야할까

>- 깔끔한 코드를 작성할 수 있다.
- 장기적으로 개발 비용을 절감할 수 있다.
- 개발이 끝나면 테스트 코드 작성하기 귀찮다.

TDD 로 개발하게 되면 일단 테스트는 작성하게 된다. 급하니까(귀찮으니까) **_일단 배포하고 나중에 시간나면 테스트 작성해!!_** 가 먹히지 않게 된다.

그리고 테스트의 역할은 잘못된 로직을 확인하기 위함도 있지만, **내가 의도한 결과물을 제대로 만들어 냈는지**를 확인해 주는 역할도 한다.

그렇기에 `테스트에 필요한 코드들만 작성`하게 되니 -> `불필요한 코드들은 작성하지 않게 되어` 깔끔한 코드를 작성할 수 있게 된다.

불필요한 코드가 없으니 유지보수에 드는 리소스가 적어지고, 이로 인해 전체적인 개발 비용이 줄어든다.

<br>

### 어떤 순서로 진행해야할까
> 1. 실패하는 작은 단위 테스트를 작성한다. 비즈니스 로직이 없기에 컴파일이 안될 수도 있다.
2. 테스트를 통과시키기 위한 비즈니스 로직을 작성한다. 전체 완성 로직이 이 테스트를 통과시킬 정도의 로직만 작성한다. 필요 시 가짜 구현이 될 수도 있다.
3. 그 다음의 테스트 코드를 작성한다. 실패 테스트가 없을 경우에만 성공 테스트를 작성한다.
4. 새로운 테스트를 통과시키기 위한 비즈니스 로직을 작성한다.
5. 1~4 단계를 반복하여 모든 테스트 케이스를 작성한다.
6. 개발된 코드들의 중복을 확인하며 리팩토링 한다.

위의 방법대로만 되면 해피한 상황이 올 것 같다. 그런데 위의 방법대로 하고 싶어도 `테스트 작성 방법` 자체에 대한 무지로 시간을 잡아먹을까 두려워 진행을 못하는 것 같기도 하다.

그리고 실패 테스트가 없을 경우에만 성공 테스트를 작성한다는게 인상 깊었다. 테스트를 짤 때 `성공 테스트를 굳이 만들어야 할까` 라는 생각을 종종 했었는데 생각해보면 실패 테이스를 다 짜놓은 상태라면 성공 테스트를 안해도 해당 로직은 잘 짠거라고 볼 수 있을 것 같다.

일단은 이정도로만 알아보고 `TDD` 책 스터디를 할 때 좀 더 딥하게 알아보겠다.


<br>

# 학습 테스트?!
이건 처음 들어봤다. 학습 테스트라니.

내가 만든 비즈니스 로직이 정상 작동하는지 확인하는 용도의 테스트는 아니고 라이브러리, 프레임워크 같은 내가 사용하는 다른 코드들에 대한 테스트를 진행해보는거다.

목적은 아직 많이 사용되지 않는 라이브러리라면 내가 실제로 사용해도 될만큼 정상적으로 작동되는 코드인지 검증하는 용도로 생각할 수도 있고.

해당 라이브러리의 기능을 더 잘 이해하고 사용하기 위해 사용 방법에 대해 말 그대로 학습하는 용도로 테스트를 작성할 수도 있다.

학습 테스트는 한 번도 해 본적이 없어서 신박했다.

다음에 라이브러리 같은걸 검토할 상황이 생기면 이 방법을 써서 로직에도 익숙해지고 검증도 하는 용도로 진행해보면 도움이 되겠다.

<br>

# 생각 해볼거리
## 테스트를 위해 비즈니스 로직 수정을 해야할까
테스트도 요구사항을 구현하기 위한 코드의 일부이므로 테스트를 잘 작성하기 위해 비즈니스 로직의 수정이 필요하다면 해야한다고 생각한다.

하지만 테스트를 위한 비즈니스 로직이 실제 비즈니스 로직에 치명적인 영향을 미치지 않는지 확인하는건 필요하다. 만약 큰 영향을 끼친다면 테스트 방법을 다르게 할 수 있도록 대안을 마련해보는게 좋다고 생각한다.

<br>

## @MockBean, @SpyBean 등을 사용하지 않는 게 좋은걸까
[@SpyBean @MockBean 의도적으로 사용하지 않기 - 기억보단 기록을](https://jojoldu.tistory.com/320) 참조

언젠가부터 테스트를 작성할 때 `@Mock`과 `@InjectMock` 을 쓰는게 당연하다고 생각을 하고 있었다. 원하는 테스트 결과를 설계하기 위해 불필요한 테스트 구현을 줄여주고 테스트 자체도 손쉽게 해주기 때문이다.

그런데 이 편함 때문에 놓치는게 있을 수 있다고 한다.

설계에 있어서의 코드 스멜을 테스트의 간편함으로 인해 놓칠 수 있다고 한다.

다른 의존성들을 무시하고 필요한 의존성만 mock 으로 처리하기 때문에 불필요한 의존성들이 설정되어 있어도 알아챌 수 없게 된다는 이야기인데...

아직은 테스트 작성 자체에도 여러 어려움이 많아서 이 이상의 논리까지 생각을 확장하기는 쉽지 않다.

일단 이 글을 읽고 무지성으로 쓰고 있던 모킹에 대해서 쓰기 전에 한 번 더 생각할 수 있게 되었다는데 의의를 두고 조금 더 테스트에 숙련이 된 후 깊이 생각해보면 좋겠다.


<br>

# 참고
[[TDD] 단위 테스트와 TDD(테스트 주도 개발) 프로그래밍 방법 소개 - 망나니 개발자] (https://mangkyu.tistory.com/182)
[@SpyBean @MockBean 의도적으로 사용하지 않기 - 기억보단 기록을](https://jojoldu.tistory.com/320) 