
> Note : 해당 문서는 [WorkFlowy](https://workflowy.com/s/result/IHodL4WnChe0lKSo
)에 최적화 되어있습니다.

# Chapter2 - Test

## What I learned?

  - 좋은 테스트코드가 가져야 할 원칙에 대한 Recall.
  - JUnit은 각 테스트 메서드 실행 전, "매번 테스트 클래스 개체"를 생성한다는 점.
  - Spring이 어떻게 테스트를 빠르고 효율적으로 실행할 수 있게 돕는지.

## Test What/How

  - What is Test?
    - 코드를 확신할 수 있게 해주는 작업
    - 항상 같은 조건에 대해, 실행순서 상관 없이, 동일한 결과를 보장해야 한다(일관성과 멱등성)
    - Testable한 코드가 좋은 코드다

  - How to Test?
    - 테스트는, 포괄적으로 작성해야 한다 (단순 100% 커버리지만 달성한 테스트는 해악이다)
    - 테스트 대상을, "작은 단위"로 쪼개어 해당 대상에만 집중해서 테스트 (SoC원리 적용)
    - 테스트 메소드를, 한 번에 한 가지 검증 목적에만 충실하기

  - JUnit에 대해서
    - JUnit이 하나의 테스트를 가져와 테스트 수행하는 방식
      - 1. Convention에 따라 테스트 메소드를 찾는다 (Test 어노테이션 붙은 void형 메서드)
      - 2. 테스트 클래스 개체 생성
      - 3. Before 어노테이션 붙은 함수 실행
      - 4. 테스트 메소드 실행
      - 5. After 어노테이션 붙은 함수 실행
      - 6. 나머지 테스트 메소드에 대해 2~5번 반복
      - 7. 결과 종합해서 리턴
      - 이때, 특정 메소드의 실행 순서를 보장하지 않는다 (당연하지만)
    - 각 테스트메서드를 실행할 때 마다 테스트 클래스의 개체를 새로 만든다!
      - Why?
        - 테스트간에 영향을 주지 않기 위해서.
        - 덕분에 인스턴스 변수도 부담없이 사용할 수 있다.
        - 그렇다면, 생성시에 시간이 걸리는 개체들을 테스트 메소드간에 재사용 할 수 있는 방법은 없나?
          - Opt1 : BeforeClass 또는 BeforeAll 어노테이션 이용해, "Static Field"에 저장 가능하다
          - Opt2 : Spring이 제공하는 Test Context Framework이용
  - 다수설과 소수설
    - 단위테스트에 DB사용시, 단위테스트가 아니다?
      - DB상태를 테스트가 관장하고 있다면 단위테스트라고 해도 무방하다?
      - TestDB가 하나인경우, 여러 곳에서 동시 실행하면 테스트 일관성이 깨지지 않나? 더 좋은 방법 없을까?
      - 실무에선 단위테스트에 필요한 데이터는 mocking해서 테스트 했다 (from Excel, CSV, etc)
      - Spring에선 어떤 방법이 권장되고 있나?
        - TODO : Vol2 상세 설명

## TDD What/Why/How

  - What is TDD?
    - Idea is simple. Write test before writing code.
    - 하지만, 기존의 "테스트에 대한 역할과 용도에 대한 업계의 인식"을 바꿔놓았다.
  - Why TDD?
    - 불확실성을 일찍 들어낼 수 있다 (ATDD부터 TDD도입하는 경우)
    - 작업 완료 후 결과를 검증하려고 테스트를 사용하는 것이 아니라, 테스트를 설계활동으로 바꾼다.
    - Testable한 코드를 작성하게므로, 결합도가 낮고 응집도 높은 코드를 작성가능하게 한다
    - 직접적으로 관련있는 코드만 작성하게 된다.
    - 설계를 따라 개발하거나, 변화가 필요할때, 자동화된 회귀 테스트라는 안전망이 되어준다.
    - 이는 결국 시스템 품질 향상(특히 새로운 요구사항에 대한 신뢰성과 유연성 부분)과 이어진다.
    - 한번에 하나에 집중할수 있다(기능 구현 + 설계 구현 두개다 한번에 고민 할 필요없다)
      - 기능구현 : Test Fail -> Test Success
      - 설계구현 : Refactoring(메서드 설계, 클래스 설계, 클린코드 구현)
  - How to TDD?
    - TDD Cycle
    - 1. Start from 인수테스트
      - Why?
        - [정량화] 인수테스트가 실패하는 동안 시스템이 아직 그 기능을 구현하지 않았다는 사실을 보여여주기에.
          - 반대로 말하면, 인수 테스트가 통과하면 작업은 끝난다.
          - 또한, 측정 가능한 진척도를 나타내는 수단이 된다.
        - [생산성] 인수 테스트를 사용해 작성하려는 코드가 "실제로" 필요한지 가늠할 수 있기에.
          - 즉, 직접 관련된 코드만 작업한다.
    - 2. 실패하는 단위 테스트 작성
    - 3. 테스트 통과 시키기
    - 4. 리팩터링
    - 5. 1로 돌아간다.
    - 이 주기를 통해, 시스템 구현과 설계에 대한 피드백을 얻는다.
      - 구현 : 시스템이 동작하는가?
      - 설계 : 시스템이 잘 구조화 되었는가?
  - 고려 할 점
    - 작은 단계로 쪼개서 스텝 바이 스텝으로 점진적으로 구현해나가기
    - 입력에서 출력순으로 개발
    - 메서드가 아닌, 행위를 테스트
    - 가장 간단한 성공 케이스부터 시작하기
    - 테스트가 실패하는 것으로부터 피드백 받기
    - 주기를 인식하고 피드백으로부터 주기 미조정
    - Regression Test와 진행상황 측정하는 테스트 분리하기

## 스프링은 얼마나 테스트를 편하게 하도록 돕는가?

  - JUnit을 이용하는 Test Context Framework제공
    - 이를 이용해, 어노테이션 설정만으로 테스트에 필요한 DI Container 생성하여, 모든 테스트 메서드가 공유하게 할 수 있다.
    - How?
      - ExtendWith(SpringExtension.class)
        - ExtendWith = JUnit 테스트 실행 방법 확장할 때 사용
        - SpringExtension을 지정하면, JUnit이 테스트가 사용할 애플리케이션 컨텍스트를 만들고 관리하는 작업을 진행한다
  - 동일한 설정파일을 이용하는 테스트는 하나의 ApplicationContext를 공유 할 수 있다
  - Autowired를 이용해 Spring Bean 을 바로 DI할 수 있다
