# Overview

---

- 자바에는 표준 스펙, 상용 제품, 오픈소스를 통틀어서 사용 방법과 형식은 다르지만 기능과 목적이 유사한 기술이 존재한다.
- 자바의 표준 기술중에서도 플랫폼과 컨텍스트에 차이가 있거나 발전한 역사가 달라 목적이 유사한 여러 기술이 공존하기도 한다.
- 환경과 상황에 따라 기술이 바뀌고 그에 따라 다른 API를 사용하고 다른 스타일의 접근 방법을 따라야하는 것은 피곤한 일이다.

# 1. 사용자 레벨 관리 기능 추가

---

- JDBC가 사용하는 SQL은 컴파일 과정에서는 자동으로 검증이 되지 않는 단순 문자열에 불과하다.
- SQL 문장이 완성돼서 DB에 전달되기 전까지는 문법 오류나 오타조차 발견하기 힘들다는게 문제다.
- 빠르게 실행 가능한 포괄적인 테스트를 만들어두면 기능의 추가나 수정이 일어날 때 그 위력을 발휘한다.

## 사용자 수정 기능 추가

- 비즈니스 로직에 따라 사용자 정보가 여러번 수정될 수 있다.
- 기본키인 id를 제외한 나머지 필드는 수정될 가능성이 있다.

## 수정 테스트 보완

- JDBC 개발에서 리소스 반환과 같은 기본 작업을 제외하면 SQL 문장에 가장 많은 실수가 일어난다.
- update의 경우 그대로 남아있는지 확인을 못한다.
- 첫 번째 방법은 update()가 돌려주는 리턴 값을 확인하는 것이다.
    - 이 리턴값이 1인지 확인하는 코드를 추가한다.
- 두 번째 방법은 테스트를 보강해서 원하는 사용자 외의 정보는 변경되지 않았음을 확인하다.

## UserService.upgradeLevels()

- UserService는 UserDao의 구현 클래스가 바뀌어도 영향받지 않도록 해야한다.

![image](https://user-images.githubusercontent.com/66561524/197366612-881c0551-d013-46c2-9e50-6a479e23559d.png)

## UserService.add()

- UserDao에 add()가 있는 것은 적합하지 않다. DB에 정보를 넣고 읽는 방법에만 관심을 가져야한다.
- 비즈니스적인 의미를 지닌 정보를 설정하는 책임을 지는 것은 바람직하지 않다.
- 사용자 관리에 대한 비즈니스 로직은 UserService에 담아야 한다.

## UserServiceTest 개선

- 숫자는 상수로 넣자

# 2 .트랜잭션 서비스 추상화

---

## 모 아니면 도

- 모든 사용자에 대해 업그레이드 작업을 진행하다가 중간에 예외가 발생해서 작업이 중단되면 어떻게 될까?

### 테스트용 UserService 대역

- 테스트용 UserService 확장 클래스를 만든다.
- 테스트 메서드를 protecetd 로 만들어 오버라이드할 수 있게 만들고 super 메서드와 같이 사용하여 예외상황을 만든다.

## 강제 예외 발생을 통한 테스트

- 도중에 예외가 발생하면 진행되었던 과정이 원래대로 돌아간다.

### 테스트 실패의 원인

- DB와 JDBC 프로그래밍은 트랜잭션을 관리한다.
- 트랜잭션은 더 이상 나눌 수 없는 단위 작업을 말한다.
    - 작업을 쪼개서 작은 단위로 만들 수 없다는 것은 트랜잭션의 핵심 속성인 원자성을 의미한다.
    - 모든 사용자에 대한 작업은 전체가 다 성공하든지 아니면 전체가 다 실패하든지 해야 한다.
    - 트랜잭션은 더 이상쪼개질 수 없는 원자와 같다. 중간에 예외가 발생해서 작업을 완료할 수 없다면 작업이 시작되지 않은 것처럼 초기 상태로 돌려놔야 한다.

## 트랜잭션 경계설정

- DB는 그 자체로도 완벽한 트랜잭션을 지원한다.
    - SQL을 이용해 다중 로우 의 수정이나 삭제를 위한 요청을 했을 때 일부 로우만 삭제되고 나머지는 안되거나 일부 필드만 수정되는 경우는 없다. 하나의 SQL 명령을 처리하는 경우는 DB가 트랜잭션을 보장해준다고 믿을 수 있다.
    - 하지만 여러 개의 SQL이 사용되는 작업을 하나의 트랜잭션으로 취급해야 하는 경우도 있다. 트랜잭션을 설명할 때  자주 언급되는 계좌이체라던지 예제에 나온 사용자 레벨 수정 작업이 그렇다.
        - 은행 시스템의 계좌이체 작업은 반드시 하나의 트랜잭션으로 묶여서 일어나야 합니다. 이체를 할 때 출금계좌의 잔고는 이체금액만큼 줄어들고 입금계좌에는 이체금액만큼 증가돼야 한다.
        - 이체 프로그램은 DB에 요청을 두 번 보낸다. DB 출금계좌의 잔고를 수정하는 것과 입금계좌 레코드의 잔고를 수정하는 두 개의 SQL이 필요하다.
        - 첫 번째 작업은 성공했지만 두 번째 SQL이 성공하기 전에 장애가 생겨서 작업이 중단될 수 있다. 이 때 두 가지 작업이 하나의 트랜잭션이 되려면 두 번째 SQL이 성공적으로 DB에서 수행되기 전에 문제가 발생할 경우에는 앞에서 처리한 SQL 작업도 취소시켜야 한다. **취소 작업을 트랜잭션 롤백(transaction rollback)**이라고 한다.
        - 반대로 여러 개의 SQL을 하나의 트랜잭션으로 처리하는 경우에 모든 SQL 수행 작업이 다 성공적으로 마무리됐다고 DB에 알려줘서 작업을 확정시켜야한다. 이것을 **트랜잭션 커밋(transaction commit)**이라고 한다.

![image](https://user-images.githubusercontent.com/66561524/197366622-26ce9b0d-c994-45e1-9219-bacb5d410631.png)
![image](https://user-images.githubusercontent.com/66561524/197366629-54c9254b-8915-4e6f-9c17-e2fab8fceb03.png)

- `setAutoCommit(false)`로 트랜잭션의 시작을 선언하고 `commit()` 또는 `rollback()`으로 트랜잭션을 종료하는 작업을 **트랜잭션의 경계설정(transaction demarcation)**이라고 한다.
- 하나의 DB 커넥션 안에서 만들어지는 트랜잭션을 **로컬 트랜잭션(local transaction)**이라고 한다.

### UserService와 UserDao의 트랜잭션 문제

- 이전의 예제에서는 Connection의 트랜잭션을 코드로 제어하지 않았다.
- 템플릿 메소드 호출 한 번에 한 개의 DB 커넥션이 만들어지고 닫히는 일까지 일어난다. 따라서 트랜잭션이 새로 만들어지고 메서드를 빠져나오기 전에 종료된다. 결국 각 메서드마다 하나의 독립적인 트랜잭션으로 실행되고 잇는 것이다.
- 트랜잭션 작업은 내구성을 보장받기 때문에 일단 커밋되고 DB 서버가 다운되더라도 그 결과는 DB에 그대로 남는다.

![image](https://user-images.githubusercontent.com/66561524/197366637-f607534b-660c-41bf-9ac0-878ba0df275e.png)

- 데이터 액세스 코드를 DAO로 만들어서 분리해놓으면 DAO 메소드를 호출할 때마다 하나의 새로운 트랜잭션이 만들어지는 구조가 된다.
    - DAO 메소드에서 DB 커넥션을 매번 만들기 때문에 어쩔 수 없이 나타나는 결과다.
    - 결국 DAO를 사용하면 비즈니스 로직을 담고 있는 UserService 내에서 진행되는 여러가지 작업을 하나의 트랜잭션으로 묶는 일이 불가능해진다.

### 비즈니스 로직 내의 트랜잭션 경계설정

- 벌크 인서트 등의 내용을 하나의 트랜잭션을 묶는 것은 좋지 않은 결과를 가져온다. 그렇다고 JDBC API와 `UserDao`의 코드를 바꾸는 일도 말이 안된다.
- 이 트랜잭션의 경계설정 작업을 `UserService`, 비즈니스 로직으로 가져와야 한다.
- `UserDao`가 가진 SQL이나 JDBC API를 이용한 데이터 액세스 코드는 최대한 그대로 남겨둔 채로 `UserService`에는 트랜잭션 시작과 종료를 담당하는 최소한의 코드만 가져오게 만들면 어느 정도 책임이 다른 코드를 분리해둔 채로 트랜잭션 문제를 해결할 수 있다.
- 트랜잭션 경계를 메소드 안에 두려면 DB 커넥션도 이 메소드 안에서 만들고 종료시킬 필요가 있다.

![image](https://user-images.githubusercontent.com/66561524/197366643-6357e223-7b30-4ac2-aeec-9f502df22b3e.png)

- UserService에서 커넥션을 가져와야 한다.

![image](https://user-images.githubusercontent.com/66561524/197366647-88eb23eb-1025-43bc-98f9-3d9e39a64611.png)

- UserDao는 Connection을 인자로 전달받아야 한다.

### UserService 트랜잭션 경게설정의 문제점

- DB 커넥션을 비롯한 리소스의 깔끔한 처리를 가능하게 했던 JdbcTemplate을 더이상 활용할 수 없다.
    - 결국 JDBC API를 직접 사용하는 초기 방식으로 돌아가야 한다.
    - try / catch/ finally 블록은 UserService에 존재한다.
    - JDBC 작업 코드의 전형적인 문제점을 가지게 된다.
- DAO의 메소드와비즈니스 로직을 담고 있는 UserService 메소드에 Connection 파라미터가 추가되어야 한다.
    - 스프링 빈으로 선언했기 때문에 Connection을 저장했다가 다른 메서드에서 사용할 수도 없다.
    - 멀티스레드 환경에서는 공유하는 인스턴스 변수에 스레드별로 생성하는 정보를 저장하다가는 서로 덮어쓰는 일이 발생한다.
    - 트랜잭션이 필요한 작업에 참여하는 UserService 메서드는 Connection 파라미터로 지저분해진다.
- Connection 파라미터가 UserDao 인터페이스 메소드에 추가되면 UserDao는 더 이상 데이터 액세스 기술에 독립적일 수가 없다.
    - JPA나 하이버네이트로 UserDao를 변경하려고 하면 Connection 대신 EntityManager나 Session 오브젝트를 UserDao의 메소드가 전달받아야 한다.
    - DAO 분리하고 DI를 적용했던 수고가 물거품이 된다.
- DAO 메서드에 Connection 파라미터를 받게하면 테스트 코드에도 영향을 미친다.

## 트랜잭션 동기화

- Data Access와 Business Logic을 깔끔하게 분리한 코드를 포기해야할 까 아니면 트랜잭션 기능을 포기해야할까? 스프링은 이 딜레마를 해결하는 방법을 제공한다.

### Connection 파라미터 제거

- 비즈니스 로직안에서 트랜잭션 경계설정을 해야한다.
- 스프링은 독립적인 **트랜잭션 동기화(transaction synchronization) 방식**을 제안한다.
    - 트랜잭션을 시작하기 위해 만든 Connection 오브젝트를 특별한 저장소에 보관해두고 이후에 호출되는 DAO의 메서드에서는 저장된 Connection을 가져다가 사용하게 하는 것이다.
    - DAO가 사용하는 JdbcTemplate이 트랜잭션 동기화 방식을 이용하도록 하는 것이다.
    - 트랜잭션이 모두 종료되면 그때는 동기화를 마치면 된다.

![image](https://user-images.githubusercontent.com/66561524/197366652-cd5b0f5b-c803-4747-b315-903878c3d4c5.png)

1. UserService는 Connection을 생성한다.
2. 이를 트랜잭션 동기화 저장소에 저장해두고 Connection의 setAutoCommit(false)를 호출해 트랜잭션을 시작시킨 후에 본격적으로 DAO의 기능을 이용하기 시작한다.
3. 첫 번째 update() 메소드가 호출된다.
4. update() 메소드 내부에서 이용하는 JdbcTemplate 메소드에서는 트랜잭션 동기화 저장소에 현재 시작된 트랜잭션을 가진 Connection 오브젝트가 존재하는지 확인한다. 이미 저장해둔 Connection이 있다면 이를 가져온다.
5. Connection을 이용해 PreparedStatement를 만들어 업데이트 SQL을 실행한다. 트랜잭션 동기화 저장소에서 DB 커넥션을 가져왔을 때는 JdbcTemplate은 Connection을 닫지 않은 채로 작업을 마친다. 

첫 번째 DB 작업을 마쳤지만 여전히 Connection은 열려있고 트랜잭션은 진행중인 채로 트랜잭션 동기화 저장소에 저장되어 있다.

1. 두 번째 update()가 호출된다. 3번과 동일
2. 트랜잭션 동기화 저장소에 Connection을 가져와 사용한다. 4번과 동일
3. SQL을 실행한다. 5번과 동일
4. 6번과 동일
5. 7번과 동일
6. 8번과 동일
7. Connection의 commit()을 호출해서 트랜잭션을 완료시킨다.
8. 트랜잭션 저장소가 더 이상 Connection 오브젝트를 저장해두지 않도록 이를 제거한다.

어느 작업 중에 예외상황이 발생하면 UserService는 즉시 Connection의 rollback()을 호출하고 트랜잭션을 종료한다. 이때도 트랜잭션 저장소에 저장된 동기화된 Connection 오브젝트는 제거해줘야 한다.

**트랜잭션 동기화 저장소는 작업 스레드마다 독립적으로 Connection 오브젝트를 저장하고 관리하기 때문에 다중 사용자를 처리하는 서버의 멀티스레드 환경에서도 충돌이 날 염려가 없다.**

### 트랜잭션 동기화 적용

- 멀티스레드 환경에서도 안전한 트랜잭션 동기화 방법을 구현하는 일이 기술적으로 간단하지는 않다.
- 스프링은 JdbcTemplate과 더불어 이런 트랜잭션 동기화 기능을 하는 간단한 유틸리티 메소드를 제공한다.

![image](https://user-images.githubusercontent.com/66561524/197366662-4bea4ee3-6e08-4fe4-b5e7-d0589cd65360.png)

- DataSource가 필요하기 때문에 dataSource 빈에 대한 DI 설정을 해둬야 한다.
- 스프링이 제공하는 트랜잭션 동기화 관리 클래스는 `TransactionSynchronizationManager`이다.
    - 트랜잭션 동기화 작업을 초기화하도록 요청한다.
- `DataSourceUtils`에서 제공하는 `getConnection()` 메소드를 통해 DB 커넥션을 생성한다.
- `DataSource`에서 `Connection`을 직접 가져오지 않고 스프링이 제공하는 유틸리티 메소드를 쓰는 이유는 이 `DataSourceUtils`의 `getConnection()` 메소드는 `Connection` 오브젝트를 생성해줄 뿐만 아니라 트랜잭션 동기화에 사용하도록 저장소에 바인딩해주기 때문이다.
- 동기화 준비가 됐으면 트랜잭션을 시작하고 DAO 메소드를 사용하는 트랜잭션 내의 작업을 진행한다. 트랜잭션 동기화가 되어있는 채로 JdbcTemplate을 사용하면 JdbcTempalte 작업에서 동기화시킨 DB 커넥션을 사용하게 된다.
- 결국 UserDao를 통해 진행되는 모든 JDBC 작업은 upgradeLevels() 메소드에서 만든 Connection 오브젝트를 사용하고 같은 트랜잭션에 참여하게 된다.
- 작업을 정상적으로 마치면 트랜잭션을 커밋하고 스프링 유틸리티 메소드의 도움을 받아 커넥션을 닫고 트랜잭션 동기화를 마치도록 요청하면 된다. 예외 발생시에는 트랜잭션을 롤백해준다.
- DB 커넥션을 다는 것과 동기화 작업 중단은 동일하게 진행한다.

### JdbcTemplate과 트랜잭션 동기화

- JdbcTemplate은 update()나 query() 같은 JDBC 작업의 템플릿 메소드를 호출하면 직접 Connection을 생성하고 종료하는 일을 모두 담당한다.
- JdbcTemplate은 영리하게 동작하도록 설계되어 있다.
    - 미리 트랜잭션이 생성되어 트랜잭션 동기화 저장소에 등록된 DB 커넥션이나 트랜잭션이 없는 경우 JdbcTempalte이 직접 DB 커넥션을 만들고 트랜잭션을 시작해서 JDBC 작업을 진행한다.
    - 반면에 비즈니스 로직에서 트랜잭션 동기화를 시작해놓았다면 그때부터 실행되는 JdbcTemplate의 메소드에서는 직접 DB 커넥션을 만드는 대신 트랜잭션 동기화 저장소에 들어있는 DB 커넥션을 가져와서 사용한다. 이미 시작된 트랜잭션에 참여하는 것이다.
- 따라서 DAO를 사용할 때 트랜잭션이 굳이 필요없다면 바로 호출해서 사용해도 되고 DAO 외부에서 트랜잭션을 만들고 이를 관리할 필요가 있다면 미리 DB 커넥션을 생성한 다음 트랜잭션 동기화를 해주고 사용하면 된다.
    - 트랜잭션 동기화를 해주고 나면 DAO에서 사용하는 JdbcTempalte이 자동으로 트랜잭션 안에서 동작한다.
- 비즈니스 로직 레벨의 트랜잭션을 적용했지만 JdbcTemplate을 포기할 필요도 없고 지저분한 Connection 파라미터를 계속 물고 다니지 않아도 된다. UserDao는 여전히 데이터 액세스 기술에 종속되지 않는 깔끔한 인터페이스 메소드를 유지하고 있다. 테스트에서 DAO를 직접 호출해서 사용하는 것도 문제가 되지 않는다.

하지만 스프링에서는 이제부터가 트랜잭션 적용에 대한 본격적인 고민의 시작이다.

## 트랜잭션 서비스 추상화

- 지금까지 만들어온 UserService와 UserDao, UserJdbc는 JDBC API를 사용하고 트랜잭션을 적용했으면서도 책임과 성격에 따라 데이터 액세스 부분과 비즈니스 로직을 잘 분리 유지할 수 있게 만든 뛰어난 코드다.

### 기술과 환경에 종속되는 트랜잭션 경계설정 코드

- 로컬 트랜잭션은 하나의 DB Connection에 종속된다.
- 별도의 트랜잭션 관리자를 통해 트랜잭션을 관리하는 **글로벌 트랜잭션(global transaction)** 방식을 사용해야 한다.
- 글로벌 트랜잭션을 적용해야 트랜잭션 매니저를 통해 여러 개의 DB가 참여하는 작업을 하나의 트랜잭션으로 만들 수 있다.
- 자바는 JDBC 외에 글로벌 트랜잭션을 지원하는 트랜잭션 매니저를 지원하기 위한 API인 **JTA(Java Transaction API)**를 제공하고 있다.

![image](https://user-images.githubusercontent.com/66561524/197366667-433fb085-f911-4b3e-9992-2c0ddb58fbd7.png)

- JTA를 이용해 여러 개의 DB 또는 메시징 서버에 대한 트랜잭션을 관리한다.
    - 애플리케이션에서는 기존 방법대로 DB는 JDBC, 메시징 서버라면 JMS 같은 API를 사용해서 필요한 작업을 수행한다.
    - 트랜잭션은 JDBC나 JMS API를 사용해서 직접 제어하지 않고 JTA를 통해 트랜잭션 매니저가 관리하도록 위임한다.
    - 트랜잭션 매니저는 DB와 메시징 서버를 제어하고 관리하는 각각의 리소스 매니저와 XA 프로토콜을 통해 연결된다.
    - 트랜잭션 매니저가 실제 DB와 메시징 서버의 트랜잭션을 종합적으로 제어할 수 있게 된다.
- JTA를 이용해 트랜잭션 매니저를 활용하면 여러 개의 DB나 메시징 서버에 대한 작업을 하나의 트랜잭션으로 통합하는 분산 트랜잭션 또는 글로벌 트랜잭션이 가능해진다.

```java
// JNDI를 이용해 서버의 Transaction 오브젝트를 가져온다.
InitialContext ctx = new InitialContext();
UserTransaction tx = (UserTransaction) ctx.lookup(USER_TX_JNDI_NAME);

tx.begin();
// JNDI(Java Naming and Directory Interface)로 가져온 dataSource를 사용해야 한다.
Connection c = dataSource.getConnection();
try {
  // 데이터 액세스 코드
  tx.commit();
} catch (Exception e) {
  tx.rollback();
  throw e;
} finally {
  c.close();
}
```

- 다중 DB를 위한 글로벌 트랜잭션을 필요하는 하는 곳은 JTA를 이용한 트랜잭션 관리 코드를 적용해야 한다.
- 그런데 UserService에서 트랜잭션 코드가 들어가면 문제가 생긴다.
    - JDBC가 아니라 Hibernate를 사용하게 되면 Session과 Transaction 오브젝트를 사용하려면 변경을 해야 한다.

### 트랜잭션 API의 의존관계 문제와 해결책

- `UserService`에 트랜잭션 경계설정 코드를 도입한 후에 클래스의 의존관계는 아래와 같은 그림과 같다.

![image](https://user-images.githubusercontent.com/66561524/197366676-7a95b771-5ebc-47b5-9c79-bc3ab40a0b9f.png)

- DAO 클래스의 구현 기술이 JDBC에서 하이버네이트나 여타 기술로 바뀌더라도 UserService 코드에 영향을 받으면 안된다.
    - OCP 원칙을 지키는 코드였다.
- 트랜잭션 때문에 서비스 추상화의 수고가 허사가 되고 있다.
- 어떻게 하면 메소드 안의 트랜잭션 경계설정 코드를 제거할 수 있을까?
    - 트랜잭션의 경계설정을 담당하는 코드는 일정한 패턴을 갖는 유사한 구조다.
    - 여러 기술의 사용 방법에 공통점이 있다면 추상화를 생각해볼 수 있다.
    - 추상화란 하위 시스템의 공통점을 뽑아내서 분리시키는 것을 말한다.
    - 하위 시스템이 어떤 것인지 알지 못해도 또는 하위 시스템이 일관된 방법으로 접근할 수가 있다.
- DB에서 제공하는 DB 클라이언트 라이브러리와 API는 서로 전혀 호환이 되지 않는 독자적인 방식으로 만들어져 있다.
    - 하지만 모두 SQL을 이용하는 방식이라는 공통점이 있다.
    - 이 공통점을 뽑아 추상화한 것이 JDBC이다.
- 트랜잭션 경계설정 방법의 공통점을 모아서 추상화된 트랜잭션 관리 계층을 만들 수 있다.
- 애플리케이션 코드에서는 트랜잭션 추상 계층이 제공하는 API를 이용해 트랜잭션을 이용하게 만들어준다면 특정 기술에 종속되지 않는 트랜잭션 경계설정 코드를 만들 수 있다.

### 스프링의 트랜잭션 서비스 추상화

- 스프링은 트랜잭션 기술의 공통점을 담은 트랜잭션 추상화기술을 제공하고 있다.

![image](https://user-images.githubusercontent.com/66561524/197366684-c378a8e0-4ddf-4bc0-bbc4-bfe6eaf8287a.png)

- 스프링이 제공하는 트랜잭션 경계설정을 위한 추상 인터페이스는 `PlatformTransactionManager`이다.
- JDBC의 로컬 트랜잭션을 이용한다면 `PlatformTransactionManager`를 구현한 `DataSourceTransactionMnager`를 사용하면 된다.
- JDBC를 이용하는 경우에 먼저 `Connection`을 생성하고 나서 트랜잭션을 시작한다. `PlatformTransactionManager`에서는 트랜잭션을 가져오는 요청인 `getTransaction()` 메소드를 호출하면 된다. 필요에 따라 트랜잭션 매니저가 DB 커넥션을 가져오는 작업도 같이 수행해준다.
    - 필요에 따라 트랜잭션 매니저가 DB 커넥션을 가져오는 작업도 수행해준다.
- 파라미터로 넘기는 `DefaultTransactionDefinition` 오브젝트는 트랜잭션에 대한 속성을 담고 있다.
- 스프링의 트랜잭션 추상화 기술은 앞에서 적용해봤던 트랜잭션 동기화 저장소에 저장된다.
- `DataSourceTransactionMnager` 오브젝트는 JdbcTemplate에서 사용될 수 있는 방식으로 트랜잭션을 관리해준다. 따라서 `PlatformTransactionManager` 를 통해 시작한 트랜잭션은 `UserDao`의 `JdbcTemplate` 안에서 사용된다.
- 트랜잭션 작업을 모두 수행한 후에는 트랜잭션을 만들 때 돌려받은 TrasnactionStatus 오브젝트를 파라미터로 해서 `PlatformTransactionManager` 의 `commit()` 메소드를 호출하면 된다. 예외가 발생하면 `rollback()` 메소드를 부른다.

### 트랜잭션 기술 설정의 분리

- 트랜잭션 추상화 API를 JTA를 이용하는 글로벌 트랜잭션으로 변경하기 위해서는 `PlatformTransactionManager` 구현 클래스를 `DataSourceTransactionManager`에서 `JTATransactionManager`로 바꿔주면 된다.
- `JTATransactionManager`는 주요 자바 서버에서 제공하는 JTA 정보를 JNDI를 통해 자동으로 인식하는 기능을 갖고 있다. 따라서 `JTATransactionManager`를 사용하기만 해도 트랜잭션 매니저/서비스와 연동해서 동작한다.

```java
PlatformTransactionManager txManager = new JTATransactionManager();
```

- 하이버네이트로 UserDao를 구현했다면 `HinbernateTransactionManager`, JPA를 적용했다면 `JPATransactionManager`를 사용하자.
- 모두 `PlatformTransactionManager` 인터페이스를 구현한 것이니 `getTransaction()`, `commit()`, `rollback()` 메소드를 사용한 코드는 손댈 필요가 없다.
- 하지만 트랜잭션 구현 클래스를 UserService가 알고 있으면 안된다. DI 원칙에 위배된다.
- 스프링의 빈으로 등록할 때 먼저 검토해야 할 것은 싱글톤으로 만들어져 여러 스레드에서 동시에 사용해도 괜찮은지이다. 상태를 갖고 있고 멀티스레드 환경에서 안전하지 않은 클래스를 빈으로 무작정 등록하면 심각한 문제가 발생한다.
    - 스프링이 제공하는 `PlatformTransactionManager`  구현 클래스는 싱글톤으로 사용이 가능하며 스프링의 싱글톤 빈으로 등록해도 좋다.

# 3. 서비스 추상화와 단일 책임 원칙

---

- 설정을 고치는 것만으로도 DB 연결 기술, 데이터 액세스 기술, 트랜잭션 기술을 자유롭게 바꿔서 사용할 수 있다.

### 수직, 수평 계층구조와 의존관계

- 기술과 서비스에 대한 추상화 기법을 이용하면 특정 기술환경에 종속되지 않는 포터블한 코드를 만들 수 있다.
    - UserDao와 USerService는 각각 담당하는 코드의 기능적인 관심에 따라 분리되고 서로 불필요한 영향을 주지 않으면서 독자적으로 확장이 가능하다.
        - 같은 계층에서 수평적인 분리라고할 수 있다.
    - 트랜잭션의 추상화는 좀 다르다. 애플리케이션의 비즈니스 로직과 그 하위에서 동작하는 로우레벨의 트랜잭션 기술이라는 아예 다른 계층의특성을 갖는 코드를 분리한다.

![image](https://user-images.githubusercontent.com/66561524/197366690-27a28bf9-b837-4016-9788-0080d67a98c8.png)

- `UserDao`와 `UserService`는 인터페이스와 DI를 통해 연결됨으로서 결합도가 낮아졌다.
- 결합도가 낮다는 건 데이터 액세스 로직이 바뀌거나 대이터 액세스 기술이 바뀐다고 할지라도 `UserService`의 코드에는 영향을 주지 않는다.
- UserDao DB 연결을 생성하는 방법에 대해 독립적이다.
    - DataSource 인터페이스와 DI를 통해 추상화된 방식으로 로우레벨의 DB 연결 기술을 사용하기 때문이다.
    - UserDao와 DB 연결기술도 결합도가 낮다. DB 풀링 라이브러리, JDBC의 원시적인 `DriverManager`를 사용하든 WAS가 JNDI를 통해 제공하는 데이터 소스 서비스를 사용하든 `UserDao`의 코드는 변하지 않는다.
- `UserService`와 트랜잭션 기술과도 스프링이 제공하는 `PlatformTransactionManager` 인터페이스를 통한 추상화 계층을 사이에 두고 사용한다.
    - 구체적인 트랜잭션 기술에 대해 독립적이다.
- 로직의 종류에 따른 수평적인 구분이든 로직과 기술이라는 수직적인 구분이든 모두 결합도가 낮고 서로 영향을 주지 않고 자유롭게 확장될 수 있는 구조다. DI가 핵심적인 역할을 한다.

## 단일 책임 원칙

- 이런 적절한 분리가 가져오는 특징은 SRP(Single Responsibility Principle, 단일 책임 원칙)으로 설명할 수 있다.
    - 하나의 모듈이 바뀌는 이유는 한 가지이다.
- 트랜잭션 기술을 JDBC에서 JTA로 변경해야 한다면 어떻게 해야할까?
- 트랜잭션 서비스의 추상화 방식을 도입하고 DI를 통해 외부에서 제어하도록 만들어서 UserService가 바뀔 이유는 한가지 뿐이 된다.
    - 트랜잭션 기술이 바뀌고 서버환경이 바뀌고 데이터를 가져오는 테이블이 바뀌고 UserDao의 구현기술이 JDBC에서 JPA로 바뀌더라도 수정할 이유가 없다.

## 단일 책임 원칙의 장점

- 기술이 바뀌면 기술 계층과의 연동을 담당하는 기술 추상화 계층의 설정만 바꿔주면 된다.
- 객체지향 설계와 프로그래밍의 원칙은 서로 긴밀하게 관련이 있다. 단일 책임 원칙을 잘 지키는 코드를 만들려면 인터페이스를 도입하고 이를 DI로 연결해야 한다. 결과로 단일 책임 원칙뿐 아니라 개방 폐쇄 원칙도 잘 지키고 모듈간에 결합도가 낮아서 서로의 변경이 영향을 주지 않고 같은 이유로 변경이 단일 책임에 집중되는 응집도 높은 코드가 나온다.
- 이런 과정에서 전략 패턴, 어댑터 패턴, 브리지 패턴, 미디에이터 패턴 등 많은 디자인 패턴이 자연스럽게 적용된다. 객체지향 설꼐 원칙을 잘 지켜서 만든 코드는 테스트하기도 편하다.
- 스프링이 지원하는 DI와 싱글톤 레지스트리 덕분에 편리하게 자동화된 테스트를 만들 수 있다.
- 지금까지 만든 코드는 모두 DI를 이용했다. 이렇게 스프링의 의존관계 주입 기술인 DI는 모든 스프링 기술의 기반이 되는 핵심 엔진이다 원리이다. 스프링이 지지하고 지원하는 좋은 설계와 코드를 만드는 모든 과정에서 사용되는 가장 중요한 도구다.
- 객체지향 기술이나 패턴을 익히고 적용하는 일이 어렵고 지루하다면 스프링에서 DI가 어떻게 적용되고 있는지를 살펴보면서 이를 따라해보자.

# 4. 메일 서비스 추상화

---

## JavaMail을 이용한 메일 발송 기능

### JavaMail 메일 발송

## JavaMail이 포함된 코드의 테스트

- 메일 서버가 준비되지 않으면 발송이 되지 않는다.
- 테스트하면서 매번 메일이 발송될 수 밖에 ㅇ벗다.
- 테스트 DB를 사용하는 것처럼 테스트용 메일 서버를 사용하고 싶다.

![image](https://user-images.githubusercontent.com/66561524/197366697-31a0ab99-1364-4c7f-aba8-b089039de75a.png)

- 굳이 테스트할 때마다 JavaMail을 직접 구동시키고 싶지 않을 수 있다. 부하가 일어날 수 있기 때문이다.

![image](https://user-images.githubusercontent.com/66561524/197366703-d3afa8a8-21e4-4572-9b3a-baad2171e565.png)

- 운영시에는 JavaMail을 쓰지만 개발서버나 테스트할 때는 JavaMail을 대신할 수 있는 동일한 인터페이스 코드가 필요하다.

## 테스트를 위한 서비스 추상화

- 실제 메일 전송을 수행하는 JAvaMail 대신에 테스트에서 사용할 JavaMail과 같은 인터페이스를 갖는 오브젝트를 사용하면 된다.

### JavaMail을 이용한 테스트의 문제점

- JavaMail에서 사용하는 오브젝트를 만들어야 메일 메시지를 생성하고 발송할 수 있다. 하지만 그 오브젝트가 인터페이스가 아니고 클래스이고 생성자가 모두 private으로 되어있을 수 있다. 또한 상속이 불가능한 final 클래스이다. 전송 기능을 맡고 있는 객체도 마찬가지다.
- 이 경우에 서비스 추상화를 해야한다.

### 테스트용 메일 발송 오브젝트

- 우리는 JavaMail을 사용하지 않고 메일 발송 기능이 포함된 코드를 테스트해야한다.
- 메일 전송 기능을 추상화해서 인터페이스를 적용하고 DI를 통해 빈으로 분리해놨다.
- 스프링이 제공한 메일 전송 기능에 대한 인터페이스가 있다. 이를 구현해서 테스트용 메일 전송 클래스를 만들면 된다. 구현해야 할 인터페이스는 `MailSender`이다.

![image](https://user-images.githubusercontent.com/66561524/197366709-ed11755e-81d9-4469-a085-fdcf788da252.png)
![image](https://user-images.githubusercontent.com/66561524/197366710-0745218a-5e4d-46ee-a37e-e5d54c4fe855.png)

### 테스트와 서비스 추상화

![image](https://user-images.githubusercontent.com/66561524/197366712-6697f807-39b5-4c13-8a5d-e4ff3ef53b66.png)

- 서비스 추상화는 테스트만을 위해서도 충분한 가치가 있다.

## 테스트 대역

- `DummyMailSender`는 `MailSender` 인터페이스를 구현했을 뿐 메소드가 비어있다.

![image](https://user-images.githubusercontent.com/66561524/197366714-f4e4662c-d9e4-4f46-a109-314923dd01c7.png)

- 운영 DB의 DataSource와 WAS의 DB Pool을 사용해야 한다.
- 테스트를 할 때는 간단한 DataSource를 사용한다.

![image](https://user-images.githubusercontent.com/66561524/197366716-593201d3-db72-4095-a80e-8a331cb9eb5f.png)

- 운영 서버에서는 JavaMailSenderImpl과 JavaMail을 통해 메일 서버로 이어지는 구성이 필요하다.
- 테스트 시에도 메일 전송 기능을 아예 뺄 수 없다. 테스트가 끝나면 다시 추가하는 것은 현실적으로 불가능하다. 그래서 DummyMailSender를 도입했다.
- 작은 기능이라도 다른 오브젝트의 기능을 사용하면 오브젝트의 기능이 바뀌었을 때 자신이 영향을 받을 수 있기 때문에 의존하고 있다고 말한다. 의존 오브젝트를 협력 오브젝트(collaborator)라고 한다.
- 테스트를 위한 간단한 환경으로 만들 수 있다. 단지 테스트만을 위해서도 DI는 유용하다.

### 테스트 대역의 종류와 특징

- 테스트 환경을 만들어주기 위해 테스트 대상이 되는 오브젝트의 기능에만 충실하게 수행하면서 빠르게 테스트를 실행할 수 있도록 사용하는 오브젝트를 통틀어서 **테스트 대역(Test Double)**이라고 한다.
- **테스트 스텁(Test Stub)**은 테스트 대상 오브젝트의 의존객체로서 존재하면서 테스트 동안에 코드가 정상적으로 수행할 수 있도록 돕는다. 일반적으로 메소드를 통해 전달하는 파라미터와 달리 테스트 코드 내부에서 간접적으로 사용한다. DI를 통해 의존 오브젝트를 테스트 스텁으로 변경해야 한다.
    - 리턴값이 필요한 메소드를 이용하는 경우에는 결과가 필요하다.
    - 필요한 정보를 리턴해주도록 미리 만들 수 있다.
    - 강제로 예외를 발생시켜 테스트 대상 오브젝트가 예외상황에서 어떻게 반응하는지 적용할 수 있다.
    - 스텁을 이용하면 간접적인 입력값을 지정해줄 수 있다.
- 하지만 테스트 대상 오브젝트의 메소드가 돌려주는 결과뿐 아니라 테스트 오브젝트가 간접적으로 의존 오브젝트에 넘기는 값과 그 행위 자체에 대해서도 검증하고 싶다면 어떻게 할까?
    
    
- 이런 경우에는 테스트 대상의 간접적인 출력 결과를 검증하고 테스트 대상 오브젝트와 의존 오브젝트 사이에서 일어나는 일을 검증할 수 있도록 특별히 설계된 목 오브젝트(mock object)를 사용해야 한다.

![image](https://user-images.githubusercontent.com/66561524/197366721-abef9ebd-b5fd-425e-b198-024b8aa3d472.png)

- 5번을 제외하면 스텁이라고 보면된다.
- 테스트는 테스트의 대상이 되는 오브젝트에 직접 입력 값을 제공하고 테스트 오브젝트가 돌려주는 출력 값, 즉 리턴 값을 가지고 결과를 확인한다.
- 문제는 테스트 대상 오브젝트는 테스트로부터만 입력을 받지 않는다. 테스트 대상이 의존하고 있는 다른 의존 오브젝트와도 커뮤니케이션을 한다. 이를 위해 별도로 준비해둔 스텁 오브젝트가 메소드 호출시 특정 값을 리턴해주도록 만들면 된다.

### 목 오브젝트를 이용한 테스트

- 테스트 대상과 의존 오브젝트 사이에 주고받는 정보를 보존해두는 기능을 가진 테스트용 의존 오브젝트인 목 오브젝트를 만들어서 사용해야 한다.
- 테스트 대상 오브젝트의 메소드 호출이 끝나고 나면 테스트는 목 오브젝트 에게 테스트 대상과 목 오브젝트 사이에서 일어났던 일에 확인을 요청해서 테스트 검증자료로 사용한다.
- 목오브젝트를 이용한 테스트라는게 작성하기는 간단하고 기능은 막강하다.
- 테스트가 수행될 수 있도록 의존 오브젝트에 간접적으로 입력 값을 제공해주는 스텁 오브젝트와 간접적인 출력 값까지 확인이 가능한 목 오브젝트는 테스트 대역의 가장 대표적인 방법이며 중요한 도구이다.

# 5. 정리

---

- 비즈니스 로직을 담은 코드는 데이터 액세스 로직을 담은 코드와 깔끔하게 분리되는 것이 바람직하다. 비즈니스 로직 코드 또한 내부적으로 책임과 역할에 따라서 깔끔하게 메서드로 정리돼야 한다.
- 이를 위해서는 DAO의 기술 변화에 서비스 계층의 코드가 영향을 받지 않도록 인터페이스와 DI를 잘 활용해서 결합도를 낮춰줘야 한다.
- DAO를 사용하는 비즈니스 로직에는 단위 작업을 보장해주는 트랜잭션이 필요하다.
- 트랜잭션의 시작과 종료를 지정하는 일은 트랜잭션 경계설정이라고 한다. 트랜잭션 경계설정은 주로 비즈니스 로직 안에서 일어나는 경우가 많다.
- 시작된 트랜잭션 정보를 담은 오브젝트를 파라미터로 DAO에 전달하는 방법은 매우 비효율적이기 때문에 스프링이 제공하는 트랜잭션 동기화 기법을 활용하는 것이 편리하다.
- 자바에서 사용되는 트랜잭션 API의 종류와 방법은 다양하다. 환경과 서버에 따라서 트랜잭션 방법이 변경되면 경계설정 코드도 함께 변경돼야 한다.
- 트랜잭션 방법에 따라 비즈니스 로직을 담은 코드가 함께 변경되면 단일 책임 원칙에 위배되며, DAO가 사용하는 특정 기술에 대해 강한 결합을 만들어낸다.
- 트랜잭션 경계설정 코드가 비즈니스 로직 코드에 영향을 주지 않게 하려면 스프링이 제공하는 트랜잭션 서비스 추상화를 이용하면 된다.
- 서비스 추상화는 로우레벨의 트랜잭션 기술과 API의 변화에 상관없이 일관된 API를 가진 추상화 계층을 도입한다.
- 서비스 추상화는 테스트하기 어려운 `JavaMail` 같은 기술에도 적용할 수 있다. 테스트를 편리하게 작성하도록 도와주는 것만으로도 서비스 추상화는 가치가 있다.
- 테스트 대상이 사용하는 의존 오브젝트를 대체할 수 있도록 만든 오브젝트를 테스트 대역이라고 한다.
- 테스트 대역은 테스트 대상 오브젝트가 원활하게 동작할 수 있도록 도우면서 테스트를 위해 간접적인 정보를 제공해주기도 한다.
- 테스트 대역 중에서 테스트 대상으로부터 전달받은 정보를 검증할 수 있도록 설계된 것을 목 오브젝트라고 한다.


