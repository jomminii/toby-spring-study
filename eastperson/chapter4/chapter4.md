# 1. 사라진 SQLException

---

## 초난감 예외 처리

![image](https://user-images.githubusercontent.com/66561524/196067104-5d79c9d3-0fc8-4dec-948d-0c073301c4d6.png)

- jdbcContext를 사용하면 SQLException을 throws 해줘야 한다.
- jdbcTemplate을 사용하면 SQLException이 사라진다.
- 

### 예외 블랙홀

- 예외를 잡고 아무구현이 없으면 예외 발생을 무시하면서도 정상적인 상황인 것 처럼 다음 라인으로 넘어간다. 분명한 의도가 있는게 아니면 이런 코드는 절대 만들어서는 안된다.

```kotlin
try {
	...
} catch (SQLException e) {

}
```

- 어떤 예외가 발생했는데도 이를 알아채리지 못한다.

```kotlin
} catch (SQLException e) {
	System.out.println(e);
}
```

```kotlin
} catch (SQLException e) {
	e.printStackTrace();
}
```

- 이런식으로 콘솔에 로그를 남겼다고 해서 예외가 처리된 것이 아니다. 이러한 코드도 없어야한다.
- 예외를 처리할 때 반드시 지켜야 할 핵심 원칙이 있다. 모든 예외는 적절하게 복구되든지 아니면 작업을 중단시키고 운영자 또는 개발자에게 분명하게 통보되어야한다.
- SQLException이 발생하는  이유는 SQL에 문법 에러가 있거나 DB에서 처리할 수 없을 정도로 데이터 액세스 로직에 심각한 버그가 있거나 서버가 죽었거나 네트워크가 끊긴 것이다.

### 무의미하고 무책임한 throws

- catch 블록으로 예외를 잡아봐야 해결할 방법도 없고 JDK API나 라이브러리가 던지는 각종 이름도 긴 예외들을 처리하는 코드를 매번throws로 선언하기 귀찮아지면 메서드 선언에 throws Exception을 붙이는 개발자가 있다.

![image](https://user-images.githubusercontent.com/66561524/196067125-9073f526-6ab9-4a10-a352-7fbe686818eb.png)

- 이런 무책임한 throws도 문제가 있다.
- 자신이 사용하려고 하는 메서드에 `throws Exception`이 선언되어있다고 생각해보자. 이 Exception 선언은 의미있는 정보를 얻을 수 없다. 따라서 적절한 처리를 통해 복구될 수 있는 예외상황도 제대로 다룰 수 있는 기회를 박탈당한다.

## 예외의 종류와 특징

- 체크 예외(checked exception)를 명시적인 처리가 필요한 예외를 사용하고 다루는 방법에는 큰 논쟁이 있다.
- 자바에서 throw를 통해 발생시킬 수 있는 예외 3가지
    - Error
        - `java.lang.Error` 클래스의 서브 클래스.
        - 주로 JVM에서 발생시킨다. 대체적으로 시스템 레벨이다.
        - 애플리케이션 코드에서 잡으려고 하면 안된다.
        - `OutOfMemoryError`나 `ThreadDeath` 에러는 catch로 잡아도 소용없다.
        - 애플리케이션에서는 이런 에러에 대한 처리는 신경쓰지 않아도 된다.
    - Exception과 체크 예외
        - `java.lang.Exception` 클래스를 개발자들이 만든 애플리케이션 코드의 작업 중에 예외상황이 발생했을 경우에 사용한다.
        - Exception 클래스는 Checked Exception과 Unchecked Exception으로 구분된다.
        - 자바 언어와 JDK의 초기 설계자들은 Checked Exception를 발생 가능한 예외에 모두 적용하려고 했었다. 그래서 IOException이나 SQLException을 비롯해 예외적인 상황에서 던져질 가능성이 있는 것들 대부분이 체크예외로 만들어졌다.
            
![image](https://user-images.githubusercontent.com/66561524/196067149-c04a490d-1b6d-492c-b3af-ace164dc2810.png)

            
    - `RuntimeException`과 언체크/런타임 예외
        - `java.lang.RuntimeException` 명시적인 예외처리를 강제하지 않아 언체크 예외라고 부른다. 에러와 마찬가지로 이 런타임 예외는 `catch` 문으로 잡거나 `throws`로 선언하지 않아도 된다.
        - 주로 프로그램의 오류가 있을 때 발생하도록 의도된 것들이다. `NullPointerException`, `IllegalArgumentException` 등이 있다.
        - 런타임 예외는 예상하지 못했던 예외상황에서 발생하는 게 아니기 때문에 굳이 catch나 throws를 사용하지 않도록 만든다.

## 예외처리 방법

### 예외 복구

- 예외상황을 파악하고 문제를 해결해서 정상 상태로 돌려놓는 것
- 예외로 인해 기본 작업 흐름이 불가능하면 다른 작업 흐름으로 자연스럽게 유도. 다시 정상으로 돌아오고 예외를 복구.
    - 네트워크가 불안해서 가끔 서버에 접속이 잘 안되는 환경에 시스템이라면 DB 서버에 접속하다 실패한 `SQLException`은 다시 시도하면서 예외를 복구할 수 있다.
    - 예외처리 코드를 강제하는 체크 예외들은 이렇게 예외를 어떤 식으로 복구할 가능성이 있는 경우에 사용한다. API를 사용하는 개발자로 하여금 예외상황이 발생할 수 있음을 인식하도록 도와주고 이에 대한 적절한 처리를 시도해버리도록 요구하는 것이다.

### 예외처리 회피

- 예외처리를 자신이 담당하지 않고 호출한 쪽으로 던져버리는 것이다.
- throws 문으로 선언해서 예외가 발생하면 알아서 던져지게 하거나 catch문으로 예외를 잡은 후에 로그를 남기고 다시 예외를 던지는(rethorw) 것이다.

```kotlin
public void add() thorws SQLException {
	// JDBC API
}
```

```kotlin
public void add() throws SQLException {
	try {
			// JDBC API
	} catch (SQLException e) {
			// 로그 출력
			throw e;
	}
}
```

- 콜백과 템플릿처럼 긴밀한 역할을 분담하고 있는 관계갈 아니라면 자신의 코드에서 발생하는 예외를 그냥 던져버리는 건 무책임한 책임회피일 수 있다.
- 예외를 회피하는 것은 예외를 복구하는 것처럼 의도가 분명해야 한다.

### 예외 전환

- 예외를 메소드 밖으로 던진다. 하지만 예외 회피와는 달리 발생한 예외를 그대로 넘기는 게 아니라 적절한 예외로 전환해서 던진다.
- 예외 전환의 목적은 보통 2가지이다.
    - 내부에서 발생한 예외를 그대로 던지는 것이 그 예외상황에 대한 적절한 의미를 부여해주지 못해 의미를 분명하게 해주는 예외로 바꿔주기 위해서다.
        - API가 발생하는 기술적인 로우레벨을 상황에 적합한 의미를 가진 예외로 변경하는 것이다.
        - 보통 전환하는 예외에 원래 발쌩한 예외를 담아서 중첩 예외(neted exception)로 만드는 것이 좋다.
        
        ```kotlin
        catch(SQLException e) {
        	...
        	throw DuplicateUserIdException(e);
        ```
        
        ```kotlin
        catch(SQLException e) {
        	...
        	throw DuplicateUserIdException().initCause(e);
        ```
        
    - 두 번째 전환 방법은 예외를 처리하기 쉽고 단순하게 만들기 위해 포장(wrap) 하는 것이다. 중첩 예외를 이용해 새로운 예외를 만들고 원인(cause)이 되는 예외를 내부에 담아서 던지는 방식은 같다.  하지만 의미를 명확하게 하려고 다른 예외로 전환하는 것이 아니다. 주로 예외처리를 강제하는 체크 예외를 언체크 예외인 런타임 예외로 바꾸는 경우에 사용한다.

## 예외처리 전략

- 예외를 효과적으로 사용하고 예외가 발생하는 코드를 깔끔하게 정리하는 데는 여러가지 신경써야 할 사항이 많다.

## 런타임 예외의 보편화

- 일반적으로 체크 예외는 일반적인 예외를 다루고 언체크 예외는 시스템 장애나 프로그램상의 오류에 사용한다.
- 문제는 체크 예외는 복구할 가능성이 조금이라도 있으니 이를 처리하는 catch 블록이나 throws 선언을 강제하고 있다.
- 이렇게 예외처리를 강제하는 것은 예외가 발생한 가능성이 있는 API 멤소드를 사용하는 개발자의 실수를 방지하기 위한 배려같지만 실제로는 예외를 제대로 다루고 싶지 않을 만큼 짜증나게 만든다.
- 엔터프라이즈 서버환경에서는 수많은 사용자가 동시에 요청을 보내고 독립적인 작업으로 취급한다. 하나의 요청을 처리하는 중에 예외가 발생하면 해당 작업만 중단시키면 그만이다.
- 애플리케이션 차원에서 예외상황을 미리 파악하고 예외가 발생하지 않도록 차단하는 게 좋다. 프로그램의 오류나 외부 환경으로 인해 예외가 발생하는 경우라면 빨리 요청의 작업을 취소하고 서버 관리자나 개발자에게 통보해주는 편이다.
- 그래서 현재 API에서도 발생시키는 예외를 언체크 예외로 정의하는 것이 일반화되고 있다.

## 애플리케이션 예외

- 런타임 예외 중심의 전략은 굳이 이름을 붙이자면 낙관적인 예외처리 기법이라고 할 수 있다.
- 복구할 수 있는 예외는 없다고 가정하고 예외가 생겨도 런타임 예외이므로 시스템 레벨에서 알아서 처리해줄 것이고 꼭 필요한 경우는 복구하거나 대응할 수 있으니 문제가없다는 낙관적인 태도이다.
- 반면에 시스템 또는 외부의 예외상황이 원인이 아니라 애플리케이션 자체의 로직에 의해 의도적으로 발생시키고 반드시 catch 해서 무엇인가 조치를 취하도록 요구하는 예외도 있다. 이를 애플리케이션 예외라고 한다.
    - 예외상황에 대한 리턴 값을 명확하게 코드화하고 잘 관리하지 않으면 혼란이 생길 수 있다.
    - 또 결과 값을 확인하는 조건문이 자주 등장할 수 밖에 없다.
    - 이 때 의도적인 예외는 checked exception을 사용하는 경우가 많다.

```kotlin
try {
	BigDecimal balance = account.withdraw(amount);
	// 정상적인 처리 결과를 출력하도록 진행
} catch(InsufficientBalanceException e) { // 체크 예외
	// InsufficientBalanceException 에 담긴 인출 가능한 잔고금액 정보
	BigDecimal availFunds = e.getAvailFunds();
	..
	// 잔고 부족 안내 메시지 준비 및 출력
}
```

## SQLExceeption은 어떻게 됐나?

- SQLException은 거의 코드 레벨에서 복구할 수 있는 방법이 없다.
- 스프링의 JdbcTemplate은 이 예외처리 전략을 따르고 있다. JdbcTemplate 템플릿과 콜백 안에서 발생하는 모든 `SQLException`을 런타임 예외인 `DataAccessException`으로 포장해서 던져준다.
- 따라서 예외처리 전략을 사용한다. 가능한 빨린 unchecked / runtime exception으로 바꿔준다.
- 스프링의 JdbcTemplate은 이 예외처리 전략을 따르고 있다. SQLException을 런타임 예외인 DataAccessException으로 포장해서 던진다. 이를 사용하는 쪽에서는 catch를 해주거나 그 외의 경우를 무시해도 되도 된다.

# 2. 예외 전환

---

- 예외 전환의 목적은 런타임 예외로 포장해서 굳이 필요하지 않은 catch/throws를 줄여주는 것이고 다른 하나는 로우레벨의 예외를 좀 더 의미있고 추상화된 예외로 바꿔서 던져주는 것이다.
- 스프링의 `JdbcTemplate`이 던지는 `DataAccessException`은 런타임 예외로 `SQLException`을 포장해주는 역할을 한다. 대부분 복구가 불가능한 예외인 `SQLException`에 대해 애플리케이션 레벨에서는 신경쓰지 않도록 해준다.

## JDBC의 한계

- JDBC는 JDK에서 가장 많이 사용되는 기능 중 하나다. DB를 이용해 데이터를 저장하고 필요한 정보를 조회하는 기능은 대부분의 애플리케이션에서 필요하기 때문이다. JDBC는 자바를 이용해 DB에 접근하는 방법을 추상화된 API 형태로 정의하고 각 DB 업체가 JDBC 표준을 따라 만들어진 드라이버를 제공하게 해준다.
- 내부 구현은 DB마다 다르지만 JDBC의 Connection, Statement, Resultset 등 표준 인터페이스를 통해 기능을 제공해주면 자바 개발자는 DB 종류와 상관없이 일관적으로 프로그래밍할 수 있다. 인테퍼에스를 사용하는 객체지향 프로그래밍의 방법의 장점을 잘 경험할 수 있는 것이 JDBC이다.
- 표준화된 JDBC API는 DB 개발 방법을 표준화했지만 DB를 자유롭게 변경해 사용하는 DB 프로그램을 작성하는 데는 두가지 걸림돌이 있다.

### 비표준 SQL

- 첫째 문제는 JDBC 코드에서 사용하는 SQL이다. SQL은 어느 정도 표준화된 언어이고 몇 가지 표준 규약이 있긴 하지만 대부분의 DB는 표준을 따르지 않는 비표준 문법과 기능도 제공한다. 이런 비표준 특정 DB 전용 문법은 폭넓게 사용되고 있다. 해당 DB의 특별한 기능을 사용하거나 최적화된 SQL을 만들 때 유용하다.
- 비표준 SQL은 결국 DAO 코드에 들어가고 해당 DAO는 특정 DB에 종속적인 코드가 된다. 다른 DB로 변경하려면 DAO에 담긴 SQL을 적지않게 수정해야 한다.
- 이 문제의 해결책을 생각해보면 호환 가능한 표준 SQL만 사용하는 방법과 DB 별로 별도의 DAO를 만들거나 SQL을 외부에 독립시켜서 DB에 따라 변경해 사용하는 방법이 있다. 하지만 표준 SQL만 사용하는 것은 결국 또다른 문제가 된다. 결국 사용할 수 있는 방법은 DAO를 DB별로 만들어 사용하거나 SQL을 외부에서 독립시켜서 바꿔 쓸 수 있게 하는것이다.

### 호환성 없는 SQLException DB 에러정보

- 두 번째 문제는 바로 `SQLException`이다. DB를 사용하다가 발생할 수 있는 예외의 원인은 다양하다. SQL의 문법 오류도 있고 DB 커넥션을 가져오지 못했을 수도 있으며 테이블이나 필드가 존재하지 않거나 키가 중복되거나 다양한 제약조건을 위배하는 시도를 한경우 데드락에 걸렸거나 락을 얻지 못했을 경우 수백여 가지에 이른다.
- JDBC는 데이터 처리 중에 발생하는 다양한 예외를 `SQLException` 하나 에  모두 담는다. 에러의 원인은 `SQLException` 안에 담긴 에러코드와 SQL 상태정보와 참조해봐야한다. DB 에러 코드는 DB 별로 모두 다르다. DB 벤더가 정의한 고유한 에러 코드를 사용하기 때문이다.
- `SQLException`은 그래서 예외가 발생했을 때 DB 상태를 담은 SQL 상태정보를 부가적으로 제공한다. 이 상태정보는 DB별로 달라지는 에러 코드를 대신할 수 있도록 Open Group XOPEN SQL 스펙에 정의된 SQL 상태 코드를 따르도록 되어있다.
- 하지만 표준 코드와는 상관없는 엉뚱한 코드가 들어가기도 하고 무관하게 0이 들어가기도 한다. 결과적으로 SQL 상태코드를 믿고 결과를 파악하는 것은 위험하다. 결국 호환성 없는 에러 코드와 표준을 잘 따르지 않는 상태 코드를 가진 `SQLException`만으로 DB에 유연한 코드를 작성하는 것은 불가능하다.

## DB 에러 코드 매핑을 통한 전환

- SQL 상태 코드는 JDBC 드라이버를 만들 때 들어가는 것이므로 같은 DB라도 드라이버를 만들 때마다 달라질 수 있지만 DB 에러 코드는 DB에서 직접 제공해줘서 어느정도 일관성이 유지된다.
- 에러 코드를 값을 확인할 수 있다면 이 에러 코드를 의미가 분명히 드러나는 예외로 전환할 수 있다. DB 종류와 상관없이 동일한 상황에서 일관된 예외를 전달 받을 수 있다면 효과적인 대응이 가능하다.
- 데이터 액세스 작업 중에 발생할 수 있는 예외상황을 수십가지 예외로 분류하고 이를 추상화해 정의한 다양한 예외 클래스를 제공한다.
- `JdbcTemplate`을 이용한다면 JDBC에서 발생하는 DB 관련 예외는 거의 신경 쓰지 않아도 된다.

## DAO 인터페이스와 DataAccessException 계층구조

- `DataAccessException`은 JDBC의 `SQLException`을 전환하는 용도로만 만들어진 것은 아니다. JDBC 외의 자바 데이터 액세스 기술에서 발생하는 예외에도 적용된다.
- `DataAccessException`은 의미가 같은 예외라면 데이터 액세스 기술의 종류와 상관없이 일관된 예외가 발생하도록 만들어준다. 데이터 액세스 기술에 독립적인 추상화된 예외를 제공하는 것이다.

### DAO 인터페이스와 구현의 분리

- DAO를 따로 만들어서 사용하는 이유는 데이터 액세스 로직을 담은 코드를 성격이 다른 코드에서 분리하기 위해서다. 분리된 DAO는 전략 패턴을 적용해 구현 방법을 변경해서 사용할 수 있기 때문이다. DAO를 사용하는 쪽에서는 DAO가 내부에서 어떤 데이터 액세스 기술을 사용하는지 신경 쓰지 않아도 된다.
- 만일 JDBC API를 사용하는 DAO 인터페이스가 Checked Exception을 던지는 경우 이 메서드를 구현할 때, 해당 예외가 아닌 Checked Exception을 던지는 메서드를 구현할 수 없다. 다행이도 JDBC 이후에 나온 Data Access 기술 대부분이 런타임 예외로 던지고 있어서 DAO 메소드안에서 Checked Exception도 런타임 예외로 포장해서 사용할 수 있다.
- 하지만 각 기술 구현체(Hibernate, JPA, Jdo)등의 예외가 다르기 때문에 이를 추상화해줘야할 필요가 있다.

## 데이터 액세스 예외 추상화와 DataAccessException 계층 구조

- 스프링의 `JdbcTemplate`은 `SQLException`의 에러코드를 DB 별로 매핑해서 그에 해당하는 의미에 `DataAccessException`의 서브클래스 중 하나로 전환해서 던져준다.
- `DataAccessException`은 자바의 주요 데이터 액세스 기술에서 발생할 수 있는 대부분의 예외를 추상화하고 있다. 데이터 액세스 기술에 상관없이 공통적인 예외도 있지만 일부 기술에서만 발생하는 예외도 있다.

![image](https://user-images.githubusercontent.com/66561524/196067187-47bc2550-ba40-4c36-8eeb-424e3b1652f1.png)

- `DataAccessException` 계층구조에서는 템플릿 메소드나 DAO 메소드에서 직접 활용할 수있는 예외도 적용되 어있다.
- `JdbcTemplate`과 같이 스프링의 데이터 액세스 지원 기술을 이용해 DAO를 만들면 사용 기술에 독립적인 일관성 있는 예외를 만들 수 있다. 결국 인터페이스 사용, 런타임 외 전환과 함께 `DataAccessException` 예외 추상화를 적용하면 데이터 액세스 기술과 구현 방법에 독립적인 이상적인 DAO를 만들 수 있다.

## DataAccessException 활용시 주의사항

- `DataAccessException`이 기술에 상관없이 어느 정도 추상화된 공통 예외로 변환해주긴 하지만 액세스 기술에 따라 구체적인 예외가 세분화되어있지 않다는 근본적인 한계 때문에 완벽하다고 기대할 수 없다. 따라서 사용에 주의를 기울여야한다.
- 예외 전환을 통해서 `SQLException`나 의미 없는 `RuntimeException`으로 뭉뚱그려서 던지는 대신 `DataAccessException` 계층으로 변경해야 한다.

# 3. 정리

---

- 예외를 잡아서 아무런 조취를 취하지 않거나 의미 없는 throws 선언을 남발하는 것은 위험하다.
- 예외는 복구하거나 예외처리 오브젝트로 의도적으로 전달하거나 적절한 예외로 전환해야한다.
- 좀 더 의미있는 예외로 변경하거나 불필요한 catch/throws를 피하기 위해 런타임 예외로 포장하는 두 가지 방법의 예외 전환이 있다.
- 복구할 수 없는 예외는 가능한 한 빨리 런타임 예외로 전환하는 것이 바람직하다.
- 애플리케이션의 로직을 담기 위한 예외는 체크 예외로 만든다.
- JDBC의 `SQLException`은 대부분 복구할 수 없는 예외이므로 런타임 예외로 포장해야 한다.
- `SQLException`의 에러코드는 DB에 종속되기 때문에 DB에 독립적인 예외로 전환될 필요가 있다.
- 스프링은 `DataAccessException`을 통해 DB에 독립적으로 적용 가능한 추상화된 런타임 예외 계층을 제공한다.
- DAO를 데이터 액세스 기술에서 독립시키려면 인터페이스 도입과 런타임 예외 전환 기술에 독립적인 추상화된 예외로 전환이 필요하다.

[읽기모임 정리](https://www.notion.so/c7fc8ef96f084eaf91f907384bd19ffd)
