# Overview

---

- 확장에는 자유롭게 열려있고 변경에는 굳게 닫혀있다는 객체지향 설계의 핵심 원칙인 개방폐쇄원칙(OCP)은 코드에서 어떤 부분은 변경을 통해 그 기능이 다양해지고 확장하려는 성질이 있고 어떤 부분은 고정되어 있고 변하지 않으려는 성질이 있음을 알려준다.
- 변화의 특성이 다른 부분을 구분해주고 각각 다른 목적과 다른 이유에 의해 다른 시점에 독립적으로 변경될 수 있는 효율적인 구조를 만들어주는 것이 개방 폐쇄 원칙이다.
- 템플릿이란 이렇게 바뀌는 성질이 다른 코드 중에서 변경이 거의 일어나지 않으며 일정한 패턴으로 유지되는 특성을 가진 부분을 자유롭게 변경되는 성질을 가진 부분으로부터 독립시켜서 효과적으로 활용할 수 있는 방법이다.

# 1. 다시보는 초난감 DAO

---

## 예외처리 기능을 갖춘 DAO

- DB 커넥션이라는 제한적인 리소스를 공유해 사용하는 서버에서 동작하는 JDBC 코드는 반드시 예외를 처리해야한다. 정상적인 JDBC 코드의 흐름을 따르지 않고 중간에 어떤 이유로든 예외가 발생했을 경우에도 사용한 리소스를 반드시 반환하도록 만들어야 한다. 그렇지 않으면 시스템에 심각한 문제를 일으킬 수 있다.

### JDBC 수정 기능의 예외처리 코드

```kotlin
public void deleteAll() throws SQLException, ClassNotFoundException {
        Connection connection = connectionMaker.makeNewConnection();

				// 예외가 발생하면 메소드 실행이 중단된다.
        PreparedStatement ps = connection.prepareStatement("delete from users");
        ps.executeUpdate();

        ps.close();
        connection.close();
    }
```

- `Connection`, `PreparedStatement` 두 개의 공유 리소스는 정상적으로 처리되면 `close()`를 호출해서 리소스를 반환한다. 하지만 예외가 발생하면 `close()` 메소드가 실행되지 않아 리소스가 반환되지 않는다.
- 서버에서는 제한된 개수의 DB 커넥션을 만들어서 재사용 가능한 pool로 관리한다. DB 풀은 매번 `getConnection()`으로 가져간 커넥션을 명시적으로 `close()`해서 돌려줘야지만 다시 풀에 넣었다가 다음 커넥션 요청이 있을 때 재사용할 수 있다. 오류가 날 때마다 반환되지 못한 Connection이 쌓이면 커넥션 풀에 여유가 없어지고 리소스가 모자라다는 심각한 오류가 내며 서버가 중단될 수 있다.

<aside>
💡 **리소스 반환과 close()**
close() 메서드는 종료하는 것이라고 볼 수도 있지만 보통 리소스를 반환한다는 의미로 이해하면 된다. Connection, PreparedStatement는 보통 풀(pool) 방식으로 운영된다.  미리 정해진 풀 안에서 제한된 수의 리소스를 만들어두고 필요할 때 이를 할당하고 반환하면 다시 풀에 넣는 방식으로 운영된다. 요청이 많은 서버환경에서 매번 새로운 리소스를 생성하는 대신 풀에 미리 만들어둔 리소스를 돌려가며 사용하는 편이 유리하며 사용한 리소스는 빠르게 반환해야 한다.

</aside>

- JDBC 코드에서 어떤 상황에서도 가져온 리소스를 반환하도록 `try`/`catch`/`finally` 구문 사용을 권장하고 있다.

# 2. 변하는 것과 변하지 않는 것

---

## JDBC try/catch/finally 코드의 문제점

- JDBC를 사용할 때 try/catch/finally 코드는 모든 메서드마다 반복된다.
- 하지만 너무 반복되며 실수가 잦게 발생한다.

## 분리와 재사용을 위한 디자인 패턴 적용

### 템플릿 메소드 패턴의 적용

- 템플릿 메소드는 패턴은 상속을 통해 기능을 확장해서 사용하는 부분이다.
- 변하지 않는 부분은 슈퍼클래스에 두고 변하는 부분은 추상 메소드로 정의해둬서 서브클래스에서 오버라이드하여 새롭게 정의해쓰도록 하는 것이다.
- 추출해서 별도의 메소드로 독립시킨 `makeStatement()` 메소드를 다음과 같이 추상 메소드 선언으로 변경한다.

```kotlin
abstract protected PreparedStatement makeStatement(Connection connection) throws SQLException;
```

- 상속하는 서브클래스를 마들어서 이 메소드를 구현한다. 상속을 통해 구체적인 `PreparedStatement`를 바꿔서 사용할 수 있게 만드는 서브클래스로 깔끔하게 분리할 수 있다.

```kotlin
public class UserDaoDeleteAll extends UserDao{
    @Override
    protected PreparedStatement makeStatement(Connection connection) throws SQLException {
        return connection.prepareStatement("delete from users");
    }
}
```

- 기능을 확장하고 싶을 때마다 상속을 통해 자유롭게 확장할 수 있다. 확장 때문에 상위 클래스에 불필요한 변화가 생기지 않으니 객체지향 설계의 핵심 원리인 개방 폐쇄 원칙(OCP)를 지키는 구조를 만들 수 있다.
- 하지만 템플릿 메소드 패턴의 접근은 제한이 많다. DAO 로직마다 상속을 통해 새로운 클래스를 만들어야 한다.

![image](https://user-images.githubusercontent.com/66561524/193371221-7e38e41d-40f6-4ed9-a7fa-a0634b9c8b35.png)

- 확장 구조가 클래스를 설계하는 시점에서 고정되어버린다. 따라서 관계에 대한 유연성이 떨어져버린다. 상속을 통해 확장하려는 템플릿 메소드 패턴의 단점이 드러난다.

### 전략 패턴의 적용

- 개방 폐쇄 원칙(OCP)을 잘 지키는 구조이면서도 템플릿 메소드 패턴보다 유연하고 확장성이 뛰어난 것은 오브젝트를 아예 둘로 분리하고 클래스 레벨에서 인터페이스를 통해서만 의존하도록 만드는 전략패턴이다.
- 전략 패턴은 OCP 관점에 보면 확장에 해당하는 변하는 부분을 별도의 클래스로 만들어 추상화된 인터페이스를 통해 위임하는 방식이다.

![image](https://user-images.githubusercontent.com/66561524/193371277-be025fd4-a4f9-4767-92c8-b2aad6946fe7.png)

- `deleteAll()` 메소드에서 변하지 않는 부분이 `contextMethod()`이다. `deleteAll()`은 JDBC를 이용해 DB를 업데이트하는 작업이라는 변하지 않는 맥락(context)을 갖는다.
- 예제로는 다음과 같은 context가 있다.
    1. DB 커넥션 가져오기
    2. `PreparedStatement`를 만들어줄 외부 기능 호출하기
    3. 전달받은 `PreparedStatement` 실행하기
    4. 예외가 발생하면 이를 다시 메소드 밖으로 던지기
    5. 모든 경우에 만들어진 `PreparedStatement`와 `Connection`을 적절히 닫아주기
    - 2번의 외부 기능이 바로 전략 패턴에서 말하는 전략이다. 이 구조를 인터페이스로 만들어두고 메소드를 통해 `PreparedStatement` 생성 전략을 호출해주면 된다.

```java
public void jdbcContextWithStatementStrategy(StatementStrategy statementStrategy) throws ClassNotFoundException, SQLException {
    Connection connection = null;
    PreparedStatement preparedStatement = null;
    try {
        connection = connectionMaker.makeNewConnection();
        preparedStatement = statementStrategy.makePreparedStatement(connection);
        preparedStatement.executeUpdate();
    } catch (SQLException e) {
        throw e;
    } finally {
        if (preparedStatement != null) { try { preparedStatement.close(); } catch (SQLException e) {} }
        if (connection != null) { try { connection.close(); } catch (SQLException e) {} }
    }
}
```

### DI 적용을 위한 클라이언트/컨텍스트 분리

- 전략 패턴에 따르면 Context가 어떤 전략을 사용하게 할 것인가는 Context를 사용하는 앞단의 Client가 결정하는 게 일반적이다.
- Client가 구체적인 전략의 하나를 선택하고 오브젝트로 만들어서 Context에 전달하는 것이다.
- Context는 전달받은 그 Strategy 구현 클래스의 오브젝트를 사용한다.

![image](https://user-images.githubusercontent.com/66561524/193371327-368c524e-8ae9-47b9-b2cf-8320761aa2c8.png)

- 전략 오브젝트 생성과 컨텍스트로의 전달을 담당하는 책임을 분리시킨 것이 바로 ObjectFactory이다. 일반화한 것이 의존관계 주입(DI)이다. DI란 이러한 전략 패턴의 장점을 일반적으로 활용할 수 있도록 만든 구조이다.

## 마이크로 DI

- 의존관계 주입(DI)은 다양한 형태로 적용할 수 있다. DI의 가장 중요한 개념은 제 3자의 도움을 통해 두 오브젝트 사이의 유연한 관계가 설정되도록 만든다. DI를 이루는 오브젝트와 구성요소의 구조나 관계는 다양하게 만들 수 있다.
- 일반적으로 DI는 의존관계에 있는 두 개의 오브젝트와 이 관계를 다이나믹하게 설정해주는 오브젝트 팩토리(DI 컨테이너) 그리고 이를 사용하는 클라이언트 4개의 오브젝트 사이에서 일어난다.
- 하지만 때로 원시적인 전략 패턴 구조를 따라 클라이언트가 오브젝트 팩토리의 책임을 함께 지니고 있을 수도 있다.
- DI가 매우 작은 단위의 코드와 메소드 사이에서 일어나기도 한다. DI는 같아보이지 않지만 세밀하게 관찰해보면 작은 단위지만 엄연히 DI가 이뤄지고 있다. 이렇게 DI의 장점을 단순화해서 IoC 컨테이너의 도움 없이 코드 내에서 적용한 경우를 마이크로 DI라고 한다. 또는 코드에의 한 DI라는 의미로 수동 DI라고 부를 수 있다.

# 3. JDBC 전략 패턴의 최적화

---

## 전략과 클라이언트의 동거

- 오브젝트 팩토리를 분리하지 않으면 런타임시 다이나믹하게 DI를 해준다는 점외엔 템플릿 메소드 패턴을 적용했을 때와 큰 차이가 없다.

### 로컬 클래스

- 로컬 클래스를 만들어서 해결할 수 있다.

### 중첩 클래스의 종류

- 다른 클래스 내부에 정의되는 클래스를 중첩 클래스(nested class)라고 한다. 중첩 클래스는 독립적으로 오브젝트로 만들어질 수 있는 스태틱 클래스(static class)와 자신이 정의된 클래스의 오브젝트 안에서만 만들어질 수 있는 내부 클래스(inner class)로 구분된다.
- 내부 클래스는 다시 범위(scope)에 따라 세 가지로 구분된다. 멤버 필드처럼 오브젝트 레벨에 정의되는 멤버 내부 클래스(member inner class)와 메소드 레벨에 정의되는 로컬 클래스(local class) 그리고 이름을 갖지 않는 익명 내부 클래스(anonymous inner class)다. 익명 내부 클래스의 범위는 선언된 위치에 따라서 다르다.

로컬 변수를 선언하듯이 선언할 수 있다. 로컬 클래스는 선언된 메소드 내에서만 사용할 수 있다. 로컬 클래스는 클래스가 내부 클래스이기 때문에 자신이 선언된 곳의 정보를 바로 접근할 수 있다. 다만 내부 클래스에서 외부의 변수를 사용할 때는 외부 변수는 반드시 `final`로 선언해줘야 한다. user 파라미터는 메소드 내부에서 변경될 일이 없으므로 `final`로 선언해도 무방하다.

```kotlin
// User 등록
public void add(final User user) throws ClassNotFoundException, SQLException {
    // add() 메소드 내부에 선언된 로컬 클래스다.
    class AddStatement implements StatementStrategy {

        @Override
        public PreparedStatement makePreparedStatement(Connection connection) throws SQLException {
            PreparedStatement preparedStatement = connection.prepareStatement(
                    "insert into users(id, name, password) values (?,?,?)");
            preparedStatement.setString(1, user.getId());
            preparedStatement.setString(2, user.getName());
            preparedStatement.setString(3, user.getPassword());
            return preparedStatement;
        }
    }
		// 중첩 클래스는 로컬 변수 user에 접근할 수 있다.
    StatementStrategy addStatement = new AddStatement();
    jdbcContextWithStatementStrategy(addStatement);
}
```

- 클래스 파일을 따로만들지도 않고 내부 클래스의 특징으로 로컬 변수를 바로 가져다 사용할 수 있다.

### 익명 내부 클래스

- 익명 내부 클래스(anonymous inner class)는 이름을 갖지 않는 클래스다.
- 클래스 선언과 오브젝트 생성이 결합된 형태로 만들어지며 상속할 클래스나 구현할 인터페이스를 생성자 대신 사용해서 만든다.
- 클래스를 재사용할 필요가 없고 구현한 인터페이스 타입으로만 사용할 경우에 유용하다.

```java
new 인터페이스이름() { 클래스 본문 };
```

# 4. 컨텍스트와 DI

---

## JdbcContext의 분리

- 전략 패턴의 구조로 보자면 UserDao의 메소드가 클라이언트고 익명 내부 클래스로 만들어지는 것이 개별적인 전략이고  `jdbcContextWithStatementStrategy()` 메소드는 컨텍스트이다.
- `jdbcContextWithStatementStrategy()` 를 클래스로 독립시키자.

### 클래스 분리

- 컨텍스트를 Class로 분리해서 만들든다.

### 빈 의존관계 변경

- 스프링의 DI는 기본적으로 인터페이스를 사이에 두고 의존 클래스를 바꿔서 사용하도록 하는 게 목적이다.
- 스프링의 빈 설정은 클래스 레벨이 아니라 런타임 시에 만들어지는 오브젝트 레벨의 의존관계에 따라 정의된다.

## JdbcContext의 특별한 DI

- 이전에 적용했던 DI에서는 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사용했다. DI에서는 클래스 레벨에서 구체적인 의존관계가 만들어지지 않도록 인터페이스를 사용했다. 인터페이스를 적용했기 때문에 코드에서 직접 클래스를 사용하지 않아도 되고 설정을 변경하는 것만으로도 얼마든지 다양한 의존 오브젝트를 변경해서 사용할 수 있다.

### 스프링 빈으로 DI

- 의존관계 주입이라는 개념을 따르면 인터페이스를 사이에 둬서 클래스 레벨에서 의존관계가 고정되지 않게하고 런타임 시에 의존할 오브젝트와 관계를 다이나믹하게 주입해주는 것이 맞다. 인터페이스를 사용하지 않으면 온전한 DI라고 볼 수 없다.
- 스프링의 DI는 넓게 보자면 객체의 생성과 관계설정에 대한 제어권한을 오브젝트에서 제거하고 외부로 위임했다는 IoC라는 개념을 포괄한다.
- 스프링 DI 구조로 만들어야 할 이유
    1. 스프링 컨테이너의 싱글톤 레지스트리에서 관리되는 싱글톤 빈이 된다.
    2. DI를 통해 다른 빈에 의존하고 있는 경우가 있다. 그 경우 DI를 위해서는 주입되는 오브젝트와 주입받는 오브젝트 양쪽 모두 스프링 빈으로 등록해야 한다. 스프링이 생성하고 관리하는 IoC 대상이어야 DI에 참여할 수 있기 때문이다. 다른 빈을 DI 받기 위해서 스프링 빈으로 등록해야한다.
    - 인터페이스를 사용하지 않는 클래스를 직접 의존하는 DI가 등장하는 경우도 있다. 중요한 것은 인터페이스의 사용 여부다.

### 코드를 이용하는 수동 DI

- 스프링의 빈으로 등록하지 않고 DI하는 방법이 있다. 내부에서 직접 DI를 적용하는 방법이다.
- 스프링 빈을 등록하지 않으면 싱글톤 레지스트리로 등록하지 못한다. 하지만 context를 싱글톤으로 만들지 않으면 서비스에서 오브젝트가 반복적으로 만들 것이다. 그래서 서버에 부담이 많이간다. 따라서 전략을 사용하는 싱글톤 객체가 context를 하나씩 가지고 있어야 한다. 따라서 그 객체가 context의 생성과 초기화를 책임져야 한다.
- context는 다른 빈을 인터페이스를 통해 의존하고 있을 것이다. 하지만 스프링의 빈이 아니니 DI 컨테이너를 통해 DI를 받을 수 없다.
    - 오브젝트를 생성하고 의존 오브젝트를 setter 메소드로 주입해주는 것이 바로 DI의 동작원리다. 사용하는 오브젝트에서 임시로 DI 컨테이너처럼 동작하도록 객체를 주입해주면 된다.

인터페스를 사용하지 않는 클래스와는 의존관계지만 스프링의 DI를 이용하기 위해 빈으로 등록해서 사용하는 방법은 오브젝트 사이의 실제 의존관계가 설정파일에 명확하게 드러난다. 하지만 DI의 근본적인 원칙에 부합하지 않는 구체적인 클래스와의 관계가 설정에 직접 노출된다.

DAO의 코드를 이용해 수동으로 DI하는 방법은 USerDao의 내부에서 만들어지고 사용되면서 그 관계를 외부에는 드러내지 않는다는 장점이 있다. 하지만 context를 여러 오브젝트가 사용해도 싱글톤으로 만들 수 없고 DI 작업을 위한 부가적인 코드가 필요하다.

상황에 따라서 적절하다고 판단되는 방법을 선택해서 사용해야 한다.

# 5. 템플릿과 콜백

---

- 지금까지는 복잡하지만 바뀌지 않는 일정한 패턴을 갖는 작업 흐름이 존재하고 그중 일부분만 자주 바꿔서 사용해야 하는 경우에 적합한 전략패턴을 사용해왔다.
- 전략 패턴의 기본 구조에 익명 내부 클래스를 활용한 방식이다. 이런 방식을 스프링에서 **템플릿/콜백 패턴**이라고 부른다.

### 템플릿

- 템플릿(template)은 어떤 목적을 위해 미리 만들어둔 모양이 있는 틀을 가리킨다.
- 프로그래밍에서는 고정된 틀안에 바꿀 수 있는 부분을 넣어서 사용하는 경우를 말한다.
- 템플릿 메소드 패턴은 고정된 틀의 로직을 가진 템플릿 메소드를 슈퍼클래스에 두고 바뀌는 부분을 서브 클래스의 메소드에 두는 구조로 이뤄진다.

### 콜백

- 콜백(callback)은 실행되는 것을 목적으로 다른 오브젝트의 메소드에 전달되는 오브젝트를 말한다.
- 파라미터로 전달되지만 값을 참조하기 위한 것이 아니라 특정 로직을 담은 메소드를 실행시키기 위해 사용한다.
- 자바에선 메소드 자체를 파라미터로 전달할 방법이 없기 때문에 메소드가 담긴 오브젝트를 전달해야한다. 그래서 펑셔널 오브젝트(functional object)라고도 한다.

## 템플릿/콜백의 동작원리

- 템플릿은 고정된 작업 흐름을 가진 코드를 재사용한다는 의미이다.
- 콜백은 템플릿 안에 호출되는 것을 목적으로 만들어진 오브젝트를 말한다.

### 템플릿/콜백의 특징

- 여러 개의 메소드를 가진 일반적인 인터페이스를 사용하는 전략 패턴의 전략과 달리 템플릿/콜백  패턴의 콜백은 보통 단일 메소드 인터페이스를 사용한다.
    - 템플릿의 작업 흐름 중 특정 기능을 위해 한 번 호출되는 경우가 일반적이기 때문이다.
- 하나의 템플릿에서 여러 종류의 전략을 사용해야 한다면 하나 이상의 콜백 오브젝트를 사용할 수도 있다.
- 콜백은 일반적으로 하나의 메소드를 가진 인터페이스를 구현한 익명 내부 클래스로 만들어진다.
- 콜백 인터페이스의 메소드는 템플릿의 작업 정보를 전달받을 파라미터를 사용한다.

![image](https://user-images.githubusercontent.com/66561524/193371399-3b71eac4-2a89-45d9-b0dc-5e4eb73978f9.png)

- 클라이언트의 역할은 템플릿 안에서 실행될 로직을 담은 콜백 오브젝트를 만들고 콜백이 참조할 정보를 제공한다. 만들어진 콜백은 클라이언트가 템플릿의 메소드를 호출할 때 파라미터로 전달된다.
- 템플릿은 정해진 작업 흐름을 따라 진행하다 내부에서 생성한 참조정보를 가지고 콜백 오브젝트 메소드를 호출한다. 콜백은 클라이언트 메소드에 있는 정보와 템플릿이 제공한 참조정보를 이용해 작업을 수행하고 그 결과를 템플릿에 돌려준다.
- 템플릿은 콜백이 돌려준 정보로 작업을 수행한다. 경우에 따라 작업 결과를 클라이언트에게 돌려주기도 한다.

DI 방식의 전략 패턴 구조와 유사하다.

- 클라이언트가 템플릿 메소드를 호출하면서 콜백 오브젝트를 전달하는 것은 메소드 레벨에서 일어나는 DI다.
- 템플릿이 사용할 콜백 인터페이스를 구현한 오브젝트를 메소드를 통해 주입해주는 DI 작업이 클라이언트가 템플릿의 기능을 호출하는 것과 동시에 일어난다. 일반적인 DI는 템플릿에 인스턴스 변수를 만들고 사용할 의존 오브젝트를 setter로 가져올 것이다. 하지만 템플릿/콜백 방식은 매번 메소드 단위로 사용할 오브젝트를 새롭게 전달받는다. 콜백 오브젝트가 내부 클래스로서 자신을 생성한 클라이언트 메소드 내의 정보를 직접 참조한다는 것도 템플릿/콜백의 고유한 특징이다. 클라이언트와 콜백이 강하게 결합되는 면도 일반적인 DI와는 조금 다르다.
- 템플릿/콜백 방식은 전략 패턴과 DI의 장점을 익명 내부 클래스 사용 전략과 결합한 독특한 활용법이라고 이해할 수 있다. 하나의 고유한 디자인 패턴으로 기억해두고 이 패턴에 녹아있는 전략 패턴과 수동 DI를 이해해야 한다.

![image](https://user-images.githubusercontent.com/66561524/193371439-93392450-5436-44ed-8d60-f4bff977e89b.png)

## 편리한 콜백의 재활용

- 템플릿/콜백 방식은 템플릿에 담긴 코드를 여기저기서 반복적으로 사용하는 원시적인 방법에 비해 장점이 많다. 하지만 아쉬운 점이 있다. 클라이언트에서 매번 익명 내부 클래스를 사용하기 때문에 상대적으로 코드를 작성하고 읽기만 불편하다.

### 콜백의 분리와 재활용

- 익명 클래스 내부에서 변하는 부분과 변하지 않는 부분을 분리하자
- 바뀌지 않는 모든 부분을 빼내서 메서드로 만들자.

```java
public void deleteAll() throws SQLException, ClassNotFoundException {
    this.jdbcContext.workWithStatementStrategy(
            // 변하지 않는 콜백 클래스 정의와 오브젝트 생성
            // 변하는 SQL 문장
            connection -> connection.prepareStatement("delete from users")
    );
}
```

리팩토링

```java
public void deleteAll() throws SQLException, ClassNotFoundException {
    this.jdbcContext.workWithStatementStrategy(
            executeSql("delete from users")
    );
}

private StatementStrategy executeSql(final String query) {
    return connection -> connection.prepareStatement(query);
}
```

- 변하는 것과 변하지 않는 것을 분리하고 변하지 않는 건 유연하게 재활용할 수 있게 만드는 간단한 원리는 단순하면서도 안전하게 작성 가능한 JDBC 활용 코드를 만들 수 있따.

### 콜백과 템플릿의 결합

- 재사용 가능한 콜백을 담고 있는 메소드라면 DAO가 공유

## 템플릿/콜백의 응용

- 스프링만큼 템플릿/콜백 패턴을 응용하는 프레임워크는 없다. 스프링의 많은 API 기능을 살펴보면 템플릿/콜백 패턴을 적용한 경우를 많이 볼 수 있따.
- 스프링을 사용하는 개발자라면 스프링이 제공하는 템플릿/콜백 기능을 잘 사용할 수 있어야 한다. 템플릿/콜백 이필요한 곳이 있으면 직접 만들어서 사용할 줄도 알아야 한다.
- 스프링이 제공하는 대부분의 기술은 구조를 이해하면 손쉽게 확장할 수 있다.
- 기본적으로 OCP를 지키고 전략 패턴과 DI를 바탕에 깔고 있어 원한다면 언제든지 확장 가능하다.
- 고정된 작업 흐름이 있고 반복되는 코드가 있다면 중복 되는 코드를 분리할 방법을 생각해보자. 중복된 코드는 먼저 메서드로 분리해보고, 일부 작업을 필요에 따라 바꿔야 한다면 전략 패턴을 적용하고 DI로 의존관계를 관리하도록 만든다. 그런데 바뀌는 부분이 한 어플리케이션 안에서 동시에 여러 종류(여러 메서드)가 있다면 템플릿/콜백 패턴을 적용해볼 수 있다.
- 전형적으로 try/catch/finally 블록을 사용하는 코드는 여기저기 자주 반복되어 템플릿/콜백 패턴을 적용하기 적당하다.
- 인터페이스를 사용해 분리하는 가장 기본적인 객체지향 원칙에만 충실하면 템플릿/콜백 패턴을 만들어 활용할 수 있다.

# 6. 스프링의 JdbcTemplate

---

- 스프링에서 제공하는 템플릿/콜백 기술을 살펴보자
- 스프링은 JDBC를 이용하는 DAO에서 사용할 수 있도록 준비된 다양한 템플릿과 콜백을 제공한다.
- 거의 모든 종류의 JDBC 코드에 사용 가능한 템플릿과 콜백을 제공할 뿐만 아니라 자주 사용되는 패턴을 가진 콜백은 다시 템플릿에 결합시켜서 간단한 메서드 호출만으로 사용이 가능하도록 만들어져 있다.
- 스프링이 제공하는 JDBC 코드용 기본 템플릿은 `JdbcTempalte`이다.

### 테스트 보완

- 스프링 개발자인 로드 존슨은 테스트를 작성할 때 항상 네거티브 테스트부터 만드는 습관이 있다고 한다.예외상황에 대한 테스트를 자꾸 빼먹는 개발자라면 의도적으로 예외적인 조건에 대해 먼저 테스트를 만드는 습관을 들이는 것도 좋다.
- 예외상황에 대한 테스트를 작성해줘야 한다. 의도적으로 예외적인 조건에 대해 먼저 테스트를 만드는 습관을 들여야 한다.

### 템플릿/콜백 패턴과 UserDao

- User 정보를 DB에 넣거나 가져오거나 조작하는 방법에 대한 핵심적인 로직만 담겨있다.
- 사용할 테이블과 필드정보가 바뀌면 UserDao의 거의 모든 코드가 바뀐다. 응집도가 높다.
- JDBC API를 사용하는 방식, 예외처리, 리소스의 반납, DB 연결을 어떻게 가져올지에 관한 책임과 관심은 모두 JdbcTemplate에게 있다.
- 책임이 다른 코드와는 낮은 결합도를 유지하고 있다. 다만 JdbcTemplate이라는 템플릿 클래스를 직접 이용한다는 면에서 특정 템플릿/콜백 구현에 대한 강한 결합을 가지고 있다.
- JdbcTemplate이 스프링에서 JDBC를 이용해 DAO를 만드는 데 사용되는 사실상 표준 기술이고 JDBC 대신 다른 데이터 엑세스 기술을 사용하지 않는 한 바뀔리도 없겠지만 더 낮은 결합도를 유지하고 싶다면 JdbcTemplate을 독립적인 빈으로 등록하고 JdbcTemplate이 구현하고 있는 JdbcOperations 인터페이스를 통해 DI를 받아 사용하도록 만들어도 된다.
- 스프링은 JdbcTemplate 외에도 십여 가지의 템플릿/콜백 패턴을 적용한 API가 존재한다. 클래스 이름이 Template로 끝나거나 인터페이스 이름이 Callback으로 끝난다면 템플릿/콜백이 적용된 것이라고 보면 된다.

# 7. 정리

---

- JDBC와 같은 예외가 발생할 가능성이 있으며 공유 리소스의 반환이 필요한 코드는 반드시 try/catch/finally 블록으로 관리해야 한다.
- 일정한 작업 흐름이 반복되면서 그중 일부 기능만 바뀌는 코드가 존재한다면 전략 패턴을 적용한다. 바뀌지 않는 부분은 컨텍스트로 바뀌는 부분은 전략으로 만들고 인터페이스를 통해 유연하게 전략을 변경할 수 있도록 구성한다.
- 같은 애플리케이션 안에서 여러가지 종류의 전략을 다이나믹하게 구성하고 사용해야 한다면 컨텍스트를 이용하는 클라이언트 메소드에서 직접 전략을 정의하고 제공하게 만든다.
- 클라이언트 메소드 안에 익명 내부 클래스를 사용해서 전략 오브젝트를 구현하면 코드도 간결해지고 메소드의 정보를 직접 사용할 수 있어서 편리하다.
- 컨텍스트가 하나 이상의 클라이언트 오브젝트에서 사용된다면 클래스를 분리해서 공유하도록 만든다.
- 컨텍스트는 별도의 빈으로 등록해서 DI 받거나 클라이언트 클래스에서 직접 생성해서 사용한다. 클래스 내부에서 컨텍스트를 사용할 때 컨텍스트가 의존하는 외부의 오브젝트가 있따면 코드를 이용해서 직접 DI 해줄 수 있다.
- 단일 전략 메소드를 갖는 전략 패턴이면서 익명 내부 클래스를 사용해서 매번 전략을 새로 만들어 사용하고 컨텍스트 호출과 동시에 전략 DI를 수행하는 방식을 템플릿/콜백 패턴이라고 한다.
- 콜백의 코드에도 일정한 패턴이 반복된다면 콜백을 템플릿에 넣고 재활하는 것이 편리하다.
- 템플릿과 콜백의 타입이 다양하게 바뀔 수 있다면 제네릭스를 이용한다.
- 스프링은 JDBC 코드 작성을 위해 JdbcTemplate을 기반으로 하는 다양한 템플릿과 콜백을 제공한다.
- 템플릿은 한 번에 하나 이상의 콜백을 사용할 수도 있고 하나의 콜백을 여러 번 호출할 수 있다.
- 템플릿/콜백을 설계할 때는 템플릿과 콜백 사이에 주고받는 정보에 관심을 둬야 한다.

템플릿/콜백은 스프링이 객체지향 설계와 프로그래밍에 얼마나 가치를 두고 있는지를 잘 보여주는 예다.
