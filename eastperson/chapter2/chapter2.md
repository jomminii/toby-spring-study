# Overview

스프링이 개발자에게 제공하는 가장 중요한 가치는 **객체지향**과 **테스트**이다. 스프링의 핵심인 IoC와 DI는 오브젝트의 설계와 생성, 관계, 사용에 관한 기술이다. 스프링은 IoC/DI를 이용하여 객체지향 프로그래밍 언어의 근본과 가치를 개발자가 손쉽게 적용하고 사용할 수 있게 도와주는 기술이다. 복잡한 애플리케이션을 개발하는데 필요한 도구 하나는 객체지향 기술이다. 다른 하나의 도구로 스프링이 강조하고 있는 가치는 테스트다.

- 확장과 변화를 고려한 객체지향적 설계와 그것을 효과적으로 담아낼 수 있는 IoC/DI 같은 기술이다.
- 만들어진 코드를 확신할 수 있게 해주고 변화에 유연하게 대처할 수 있는 자신감을 주는 테스트 기술이다.

스프링 개발자라면 테스트 작성 방법과 이를 효과적으로 개발에 활용하는 전략을 알고 실전에 적용할 수 있어야 한다. 또한 테스트는 스프링을 학습하는데 가장 효과적인 방법의 하나이다. 

# 1. UserDaoTest 다시 보기

## 테스트 유용성

- 처음과 동일한 기능을 수행함을 보장해줄 수 있는 방법
- 테스트란 내가 예상하고 의도했던 대로 코드가 정확히 동작하는지 확인해서 만든 코드를 확인할 수 있게 해주는 작업
- 테스트가 실패하면 코드나 설계에 결함이 있음
- 최종적으로 테스트가 성공하면 모든 결함이 제거되었다는 확신을 얻을 수 있다.

### 웹을 통한 DAO 테스트 방법의 문제점

- 웹 애플리케이션에서 프레젠테이션, 서비스 계층, DAO를 포함한 모든 계층을 만들어 놓고 테스트를한다.
    - 이런 경우 어디서 문제가 발생했는지 모른다. DB, 서비스, 프레젠테이션 계층을 모두 뒤져야한다. 정작 웹화면에서 문제가 발생하는 경우도 있다.

## UserDaoTest의 특징

```kotlin
public class UserDaoTest {
    public static void main(String[] args) {
        // DaoFactory 를 설정정보로 사용하는 애플리케이션 컨텍스트 ApplicationContext 타입
        // @Configuration 이 붙은 자바 코드를 설정정보로 사용하기 위해서는 AnnotationConfigApplicationContext 사용
        ApplicationContext applicationContext = new AnnotationConfigApplicationContext(DaoFactory.class);
        UserDao userDao = applicationContext.getBean("userDao", UserDao.class);
        UserDao userDao2 = applicationContext.getBean("userDao", UserDao.class);
        System.out.println(userDao);
        System.out.println(userDao2);
        System.out.println(userDao == userDao2);
        /*
        springbook.user.dao.UserDao@74e52303
        springbook.user.dao.UserDao@74e52303
        true
         */
    }
}
```

### 작은 단위의 테스트

- 테스트하고자 하는 대상이 명확하다면 그 대상에게만 집중해서 테스트하는 것이 바람직하다. 따라서 테스트는 가능하면 작은 단위로 쪼개서 집중해야 한다.
- 작은 단위의 코드에 대해 테스트를 수행한 것을 단위 테스트(unit test)라고 한다.
- 하나의 관심에 집중해서 효율적으로 테스트할만한 범위의 단위라고 보면 된다.
- DB와 같이 통제할 수 없는 외부의 리소스에 의존하는 테스트는 단위 테스트가 아니라고 할 수도 있다.
- 때로는 통합 테스트가 필요할 수 있다. 하지만 단위별로 테스트를 실행하고 통합 테스트를 하면 오류를 잡기 수월하다.

### 자동수행 테스트 코드

- 테스트는 자동으로 자주 수행해도 부담이없도록 코드를 작성하는 것이 중요하다.
- 프로덕션 코드에 테스트 코드를 넣기보다는 별도로 테스트용 클래스를 만들어서 분리하는 것이 좋다.
- 자동으로 수행되는 테스트의 장점은 자주 반복할 수 있다는 점이다.
- 간단한 수정이라고 하더라도 그럭저럭 돌아가는 코드를 짤 ㅅ ㅜ있다.

### 지속적인 개선과 점진적인 개발을 위한 테스트

- 테스트가 없었다면 다양한 방법을 동원해서 코드를 수정하고 설계를 개선해나가는 과정이 미덥지 않을 수 있다.
- 작은 단계를 거치는 동안 테스트를 수행해서 확신을 가지고 코드를 변경해갔기 때문에 전체적으로 코드를 개선하는 작업에 속도가 붙고 더 쉬워졌을 것이다.
- 테스트를 이용하면 새로운 기능도 기대한 대로 동작하는지 확인할 수 있을 뿐 아니라 기존에 만들어뒀던 기능들이 새로운 기능을 추가하느라 수정한 코드에 영향을 받지 않고 여전히 잘 동작하는지를 확인할 수도 있다.

## UserDaoTest의 문제점

- main()에서 출력한 값을 눈으로 확인해야 하는 과정이 있으면 잦동 테스트라고 할 수 없다.
- main 메소드가 수백개 만들어진다면 모든 main을 실행해야 한다는 단점이 있다.

# 2. UserDaoTest 개선

## 테스트 검증의 자동화

- 테스트 실패는 2가지로 분류할 수 있다.
    - 테스트 에러
        - 테스트 진행도중 에러가 발생해서 실패
    - 테스트 실패
        - 결과가 기대한 것과 다르게 나오는 경우

- 자동화 테스틀 위한 xUnit 프레임워크를 만든 켄트 벡은 “테스트란 개발자가 마음 편하게 잠자리에 들 수 있게 해주는 것”이라고 했다.
- 만들어진 코드의 기능을 모두 점검할 수 있는 포괄적인 테스트(comprehensive test)를 만들면 과감한 수정을 하고도 테스트를 돌려보기만 하면된다. 또한 영향을 받는 부분을 찾을 수 있다.

## 테스트의 효율적인 수행과 결과 관리

- main 메소드로 테스트하는 것은 한계가 있다.
- 일정한 패턴을 가진 테스트를 만들 수 있고 테스트가 실패한 곳을 빠르게 찾을 수 있는 기능을 갖춘 테스트 지원도구와 그에 맞는 테스트 작성 방법이 필요하다.
- 자바 테스팅 프레임워크라고 불리는 Junit은 자바로 단위 테스트를 만들 때 유용하다.

### JUnit 테스트로 전환

- 프레임워크는 개발자가 만든 클래스에 대한 제어 궈한을 넘겨받아 주도적으로 애플리케이션의 흐름을 제어한다.
- 개발자가 만든 클래스의 오브젝트를 생성하고 실행하는 일은 프레임워크에 의해 진행된다.
- JUnit 프레임워크에서 동작하는 코드는 main 메서드 혹은 오브젝트를 만들어서 실행시키는 코드를 만들 필요가 없다.

### 테스트 메소드 전환

- 기존에 만들었던 main 메서드는 프레임워크에 적용하기에 적합하지 않다. 제어권을 직접 갖는다는 의미기 때문이다.
- main 메소드에 있는 테스트 코드를 일반 메소드에 옮기는 것이다.
- 새로 만들 테스트 메소드는 **JUnit 프레임워크가 요구하는 조건 두 가지**를 따라야 한다.
    - 메소드가 `public`으로 선언돼야 한다.
    - 메소드에 `@Test`라는 애노테이션을 붙여주는 것이다.

### 검증 코드 전환

- `assertThat`이라는 스태틱 메소드를 이용한다.
    - 첫 번째 파라미터의 값을 뒤에 나오는 매처(matcher)라는 조건으로 비교해서 일치하면 pass, 실패를 만들기도 하낟.
- JUnit은 예외가 발생하지 않거나 `assertThat()`에서 실패하지 않고 메소드의 실행이 완료되면 테스트가 성공한다고 인식한다.

# 3. 개발자를 위한 테스팅 프레임워크 JUnit

- JUnit은 사실상 자바의 표준 테스팅 프레임워크이다.
- 테스트 없이는 스프링도 의미 없다. 스프링 프레임워크 자체도 JUnit 프레임워크를 이용해 테스트를 만들어가며 개발됐다.
- 스프링 테스트 모듈도 JUnit을 이용한다.

## 테스트 결과의 일관성

- 테스트가 외부 상태에 따라 성공하기도 하고 실패하기도 하면 안된다.
- 가령 DB 서버가 다운됐다거나 네트워크에 장애가 생겨 DB에 접근하지 못하는 예외적인 상황이라면 이해할 수 있지만 그 외에는 별도의 준비 작업없이 성공해야 한다.

### 동일한 결과를 보장하는 테스트

- DB에 남아있는 데이터 같은 외부 환경에 영향을 받지 말아야 한다.
- 테스트를 실행하는 순서에 영향을 받지 않아야 한다.

## 포괄적인 테스트

- 테스트를 안 만드는 것도 위험한 일이지만 성의 없이 테스트를 만들어서 문제가 있는 코드를 테스트에 성공하게 만드는 것은 더 위험한다.
- 한 가지 결과만 검증하고 마는 것은 상당히 위험하다.
- 테스트 메소드는 한 번에 한 가지 검증 목적에만 충실한 것이 좋다.
- JUnit은 특정한 테스트 메소드의 실행 순서를 보장해주지 않는다.
- 스프링 창시자인 로드 존슨은 “항상 네거티브를 먼저 만들라”는 조언을 했다.
- 테스트를 작성할 때 부정적인 케이스를 먼저 만드는 습관을 들이는 게 좋다.

## 테스트가 이끄는 개발

- 먼저 실패하는 테스트를 만들고 구현을 한다. 테스트할 코드도 안 만들어놓고 테스트 코드부터 만드는 것은 좀 이상해보인다. 하지만  이런 순서를 따라 개발하는 구체적인 개발 전략이 존재한다.
- 기능설계, 구현, 테스트라는 일반적인 개발 흐름의 기능설계에 해당하는 부분을 테스트 코드가 일부분 담당하게 만드는 방법이다.
- 테스트가 실패하면 설계한 대로 코드가 만들어지지 않았음을 알 수 있다. 문제가 되는 부분이 무엇인지 대한 정보도 테스크 결과를 얻을 수 있다. 코드를 수정하고 테스트를 수행해서 테스트가 성공하도록 다듬어간다. 테스트가 성공하면 코드 구현과 테스트 두 가지 작업이 동시에 끝난다.

### 테스트 주도 개발

- 만들어진 코드를 검증해줄 수 있도록 테스트 코드를 먼저 만들고 테스트를 성공하게 해주는 코드를 작성하는 방식의 개발 방식이 있다. 이를 테스트 주도 개발(TDD, Test Driven Development)이라고 한다. 또는 테스트를 코드보다 먼저 작성한다고 해서 테스트 우선 개발(Test First Development)이라고도 한다.
- TDD는 개발자가 테스트를 만들어가며 개발하는 방법이 주는 장점을 극대화한 방법이라고 볼 수 있다. **“실패한 테스트를 성공시키기 위한 목적이 아닌 코드는 만들지 않는다”가 TDD의 기본 원칙**이다.
- 코드를 만들고 테스트를 짜기는 귀찮아진다. 또한 작성한 코드가 많으면 무엇을 테스트할지 막막하다. TDD는 아예 테스트를 먼저 만들고 그 테스트가 성공하도록 하는 코드만 만드는 식으로 진행하기 때문에 테스트를 빼먹지 않고 꼼꼼하게 만들 수 있다.
- 코드를 만들고 테스트를 수행할 때까지 걸리는 시간은 0에 가깝다. 이미 테스트를 만들어뒀기 때문에 코드를 작성하면 바로바로 테스트를 실행해볼 수 있다.
- 테스트가 성공하는 것을 보면서 작성한 코드에 대한 확신을 가질 수 있다.
- TDD에서는 테스트를 작성하고 이를 성공시키는 코드를 만드는 작업의 주기를 가능한 짧게 가져가도록 궈장한다.
- TDD를 하면 자연스럽게 단위 테스트를 만들 수 있다.
- 테스트는 코드를 작성한 후에 가능한 빨리 실행할 수 있어야 한다. 테스트는 애플리케이션 코드보다 작성하기 쉬운데다 각 테스트가 독립적이기 때문에 작성하는 시간은 오래 걸리지 않는다. 테스트 덕분에 오류를 빨리 잡아낼 수 있어서 전체적인 개발 속도는 오히려 빨라진다.

## 테스트 코드 개선

- JUnit이 하나의 테스트 클래스를 가져와 수행하는 방식은 다음과 같다.
    1. 테스트 클래스에서 `@Test`가 붙은 `public`이고 `void`이며 파라미터가 없는 테스트 메서드를 찾는다.
    2. 테스트 클래스의 오브젝트를 하나 만든다.
        - 각 테스트 메소드를 실행할 때마다 만든다. 한 번 만들어진 테스트 클래스의 오브젝트는 하나의 테스트 메소드를 사용하고나면 버려진다.
            - JUnit 개발자는 각 테스트가 서로 영향을 주지 않고 독립적으로 실행됨을 보장해주기 위해 매번 새롭게 오브젝트를 만들게 했다. 덕분에 인스턴스 변수도 부담없이 사용할 수 있다. 다음 테스트 메서드가 실행될 때 오브젝트가 새롭게 만들어져 다 초기화 될 것이다.
    3. `@Before`가 붙은 메소드가 있으면 실행한다.
    4. `@Test`가 붙은 메서드를 하나 호출하고 테스트 결과를 저장한다.
    5. `@After`가 붙은 메소드가 있으면 실행한다.
    6. 나머지 테스트 메소드에 대해 반복한다.
    7. 모든 테스트의 결과를 종합해서 돌려준다.

![image](https://user-images.githubusercontent.com/66561524/192071690-6bb631a2-5e34-40e3-8049-da369c61691d.png)

### 픽스처

- 테스트를 수행하는 데 필요한 정보나 오브젝트를 픽스처(fixture)라고 한다. 픽스처는 여러 테스트에서 반복적으로 사용하기 때문에 `@Before` 메소드를 이용해 생성해두면 편리한다.

# 4. 스프링 테스트 적용

- `@Before` 메소드는 테스트 메소드 개수만큼 반복되기 때문에 애플리케이션 컨텍스트는 세 번 만들어진다.
- 빈이 많아지고 복잡해지면 애플리케이션 컨텍스트 생성에 많은 시간이 걸린다. 애플맄에ㅣ션 컨텍스트가 만들어질 때는 모든 싱글톤 빈 오브젝트를 초기화한다.
    - 어떤 빈은 오브젝트가 생성될 때 자체적인 초기화 작업을 진행해서 많은 시간을 필요로 한다.
    - 어떤 빈은 많은 리소스를 할당하거나 독립적인 스레드를 띄우기도 한다.
    - 테스트를 마칠 때마다 애플리케이션 컨텍스트 내의 빈이 할당한 리소스를 깔끔하게 정리해줘야 다음 테스트에서 새로운 애플리케이션 컨텍스트의 문제를 방지할 수 있다.
- 테스트는 가능한 한 독립적으로 새로운 오브젝트를 만들어서 사용하는 것이 원칙이지만 생성에 많은 시간과 자원이 소모되는 경우에 테스트 전체가 공유하는 오브젝트를 만들기도 한다.
- 이때도 테스트는 일관성있는 실행 결과를 보장하며 실행 순서에 영향을 받지 않아야 한다.
- 애플리케이션 컨텍스트는 초기화되고 나면 내부의 상태가 바뀌는 일은 거의 없다. 빈은 싱글톤으로 만들어서 상태를 갖지 않는다. 따라서 애플리케이션 컨텍스트는 한 번만 만들고 여러 테스트가 고유해서 사용해도 된다.
- JUnit은 매번 테스트 클래스의 오브젝트를 새로 만든다. JUnit은 테스트 클래스 전체에 걸쳐 딱 한 번만 실행되는 `@BeforeClass` 스태틱 메소드를 지원한다. 이 메소드에서 애플리케이션 컨텍스트를 만들어 스태틱 변수에 저장해두고 테스트 메소드에서 사용하게 할 수 있다.

## 테스트를 위한 애플리케이션 컨텍스트 관리

- 스프링은 JUnit을 이용하는 테스트 컨텍스트 프레임워크를 제공한다.
- 테스트 컨텍스트의 지원을 받으면 간단한 애노테이션 설정만으로 테스트에서 필요로 하는 애플리케이션 컨텍스트를 만들어서 모든 테스트가 공유하게 할 수 있다.

## 스프링 테스트 컨텍스트 프레임워크 적용

- `@RunWith`는 JUnit 프레임워크의 테스트 실행방법을 확장할 때 사용하는 어노테이션
    - JUnit5에서는 `@ExtendWith`
- `@ContextConfiguration`은 자동으로 만들어줄 애플리케이션 컨텍스트의 설정파일 위치를 지정한다.

### 테스트 메서드의 컨텍스트 공유

```kotlin
// 스프링 테스트 컨텍스트 프레임워크의 JUnit 확장 기능 지정
@ExtendWith(SpringExtension.class)
// 테스트 컨텍스트가 자동으로 만들어줄 애플리케이션 컨텍스트 지정
@ContextConfiguration(classes = { DaoFactory.class })
public class UserDaoTest {
    
    @Autowired
    public UserDao userDao;

    // 테스트 오브젝트가 만들어지고 나면 스프링 테스트 컨텍스트에 의해 자동으로 값 주입
    @Autowired
    private ApplicationContext applicationContext;

    @BeforeEach
    public void setUp() {
        System.out.println(this.applicationContext);
        System.out.println(this);
    }

		// 2개 메소드 생략
}
```

실행시

```kotlin
org.springframework.context.support.GenericApplicationContext@41a2befb, started on Fri Sep 09 14:30:13 KST 2022
springbook.user.dao.UserDaoTest@60b4beb4
org.springframework.context.support.GenericApplicationContext@41a2befb, started on Fri Sep 09 14:30:13 KST 2022
springbook.user.dao.UserDaoTest@4b770e40
```

- `ApplicationContext`는 동일한 객체이지만 테스트 오브젝트는 새롭게 만든다.
- 스프링 JUnit 확장기능은 테스트가 실행되기 전 딱 한 번만 애플리케이션 컨텍스트를 만들어놓고 테스트 오브젝트가 만들어질 때마다 애플리케이션 컨텍스트 자신을 테스트 오브젝트의 특정 필드에 특별한 방법으로 주입한다.
    - 테스트 수행속도가 빨라진다.
    - 최초로 애플리케이션 컨텍스트가 만들어질 때 가장 오랜시간이 소모된다.
- 하나의 테스트 클래스 내의 테스트 메소드는 같은 애플리케이션 컨텍스트를 공유해서 사용할 수 있다.

### 테스트 클래스의 컨텍스트 공유

- 여러 개의 테스트 클래스가 있는데 모두 같은 설정파일을 가진 애플리케이션 컨텍스트를 사용한다면 스프링은 테스트 클래스 사이에서도 애플리케이션 컨텍스트를 공유하게 해준다.
- 두 개의 테스트 클래스가 같은 설정파일을 사용하는 경우(`@ContextConfiguration(classes = { DaoFactory.class })`)에 테스트 수행중에는 단 한개의 애플리케이션 컨텍스트만 만들어진다.
- 두 테스트 클래스의 모든 메소드가 하나의 애플리케이션 컨텍스트에 공유하게 되는 것이다.
- 수백 개 테스트 클래스를 만들어도 같은 설정파일을 사용하면 단 한개의 애플리케이션 컨텍스트만 만들어져 사용된다.

## @Autowired

- `@Autowired`는 스프링의 DI에 사용되는 애노테이션이다.
- `@Autowired`가 붙은 인스턴스 변수가 있으면 테스트 컨텍스트 프레임워크는 변수 타입과 일치하는 컨텍스트 내의 빈을 찾는다. 일반적으로는 주입을 위해 생성자나 setter 메소드가 필요하지만 테스트의 경우에는 필요가 없다. 또한 DI 설정없이 필드의 타입정보를 이용해 빈을 가져올 수 있는데 이런 방법을 타입에 의한 자동 와이어링이라고 한다.
- 그런데 `@Autowired private ApplicationContext applicationContext;` 이 경우에는 어떤 이유로 애플리케이션 컨텍스트가 DI되었을까
    - 스프링 애플리케이션 컨텍스트는 초기화할 때 자기 자신도 빈으로 등록한다.
    - 따라서 DI도 가능하다.
- `@Autowired`는 타입으로 가져올 빈 하나를 선택할 수 없는 경우에 변수의 이름과 같은 이름의 빈이 있는지 확인한다.
- 개발자가 만드는 테스트는 코드 내부구조와 설정 등을 알고 있고 의도적으로 내용을 검증해야할 필요가 있다. 하지만 꼭 필요하지 않다면 테스트에서도 인터페이스를 사용해서 느슨하게 연결해두자.

## DI와 테스트

- 우리가 테스트를 진행할 때 의존성 주입할 오브젝트의 타입을 인터페이스가 아닌 구현체로 명시하는 경우가 있다. 꼭 변하지 않을 구현체라고 생각해서이다.
- 하지만 그럼에도 인터페이스를 두고 DI를 적용하는 것이 맞다.
    - 소프트웨어 개발에서 절대로 바뀌지 않는 것은 없다.
    - 클래스의 구현 방식은 바뀌지 않는다고 하더라도 인터페이스를 두고 DI를 적용하게 해두면 다른 차원의 서비스 기능을 도입할 수 있다.
        - Adapter 패턴 등으로 기능을 추가할 수 있다.
        - 이런 기법을 추상화해서 AOP를 만들었고 DI가 없었으면 사용을 하지도 못했을 것이다.
    - 효율적인 테스트를 손쉽게 만들기 위해서라도 DI를 적용해야 한다.
        - 테스트는 가능한 작은 단위에서 실행되어야 하고 DI는 이러한 설계를 도와준다.

### 테스트 코드에 의한 DI

- DI는 스프링 컨테이너에서만 할 수 있는 작업이 아니다.
- 따라서 테스트 코드내에서 직접 DI를 해도 된다.
- 가령 테스트 코드에서 DataSource를 테스트용 DB를 이용하도록 수정하는 것이다.
- `@DirtiesContext` 어노테이션을 추가하면 해당 클래스의 테스트에서 애플리케이션 컨텍스트의 상태를 변경한다는 것을 알려준다.
    - 테스트 컨텍스트는 이 어노테이션이 붙은 클래스에는 애플리케이션 공유를 허용하지 않는다.
    - 메소드 실행마다 새로운 애플리케이션 컨텍스트를 만들어서 사용한다.
    - 빈의 의존관계를 강제로 DI 할 수 있다. 하지만 리소스가 많이 낭비된다.

### 테스트를 위한 별도의 DI 설정

- DAO가 테스트에서만 다른 DataSource를 사용하게 할 수 있는 방법
    - `@ContextConfiguration(classes = { TestDaoFactory.class })`
    - Configuration 파일을 별도로 만든다.

### 컨테이너 없는 DI 테스트

- 스프링 DI 컨테이너에 의존하지 않는다.
- 테스트 코드에서 직접 오브젝트를 만들고 DI해서 사용한다
    - `@ExtendWith(SpringExtension.class)` 등의 설정을 모두 삭제한다.
    - `@BeforeEach`에서 직접 객체를 생성해서 중비해준다.
- 애플리케이션 컨텍스트가 없으니 가벼운 오브젝트로 별 부담없이 테스트할 수 있다.
- 이렇게 가볍고 깔끔한 테스트를 만들 수 있는 이유가 DI를 적용했기 때문이다.
- DI는 객체지향 프로그래밍 스타일이다.

### 침투적 기술과 비침투적 기술

- 침투적(invasive)기술은 적용했을 때 애플리케이션 코드에 기술 관련 API가 등장하거나 특정 인터페이스나 클래스를 사용하도록 강제하는 기술을 뜻한다.
    - 침투적 기술을 사용하면 애플리케이션 코드가 해당 기술에 종속되는 결과를 가져온다.
- 비침투적(noinvasive)인 기술은 애플리케이션 로직을 담은 코드에 아무런 영향을 주지 않고 가능하다.
    - 기술에 종속적이지 않은 순수한 코드를 유지할 수 있게 해준다.
- 스프링은 이런 비침투적인 기술의 대표적인 예이다. 스프링 컨테이너 없는 DI 테스트도 가능하다.

DI가 적용된 코드는 테스트에서 다양한 방식으로 활용할 수 있다. DI를 어디에 적용할지 고민될 경우 효과적인 테스트를 만들기 위해서는 어떤 필요가 있을지 고민하자. 두 개의 모듈이 강하게 결합되어 있어 DI가 불가능한 구조로 만든다면 테스트할 때 불편해지거나 자동화된 테스트가 아예 불가능할 수 있다. 일반적으로 테스트하기 좋은 코드가 좋은 코드이다. 테스트하기 불편한 좋은 코드를 아직 본적이 없다.

### DI를 이용한 테스트 방법 선택

- 항상 스프링 컨테이너 없이 테스트할 수 있는 방법을 가장 우선적으로 고려하자.
- 여러 오브젝트와 복잡한 의존관계를 갖고 있는 오브젝트를 테스트할 때 스프링의 설정을 이용한 DI 방식의 텟트트를 이용하자. 다만 설정 파일은 테스트 전용으로 분리하는 것을 권장한다.
- 예외적인 의존관계를 강제로 구성해야할 때는 테스트 코드에서 수동으로 하며 `@DirtiesContext` 어노테이션을 꼭 붙이자.

# 5. 학습 테스트로 배우는 스프링

- 일반적으로 애플리케이션 개발자는 자신이 만들고 있는 코드에 대해만 테스트를 작성하면 된다. 하지만 때로는 자신이 만들지 않은  프레임워크나 다른 개발팀에서 만들어서 제공한 라이브러리 등에 대해서도 테스트를 작성해야 한다. 이런 테스트를 **학습 테스트(learning test)**라고 한다.
- 학습 테스트의 목적은 사용할 API나 프레임워크의 기능을 테스트로 보면서 사용 방법을 익히는 것이다.
    - 기능에 대해 얼마나 제대로 이해하고 있는지 사용 방법을 알고 있는지를  검증하는 것이 목적이다. 또한 테스트 코드를 작성하면서 사용법을 익히기도 한다.
- 새로운 프레임워크나 기술을 사용할 때 항상 테스트 코드로 사용법을 익히고 내가 가진 기술에 대한 지식도 검증해보자.

## 학습 테스트의 장점

### 다양한 조건에 따른 기능을 손쉽게 확인해볼 수 있다.

- 자동화된 테스트 코도로 만들어지기 때문에 다양한 조건에 따라 기능이 어떻게 동작하는지 빠르게 확인할 수 있다.

### 학습 테스트 코드를 개발 중에 참고할 수 있다.

- 다양한 기능과 조건에 대한 테스트 코드를 개별적으로 만들고 남겨둘 수 있다.
- 실제 개발에서 샘플 코드로 참고할 수 있다.
- 익숙하지 않은 기술을 사용해야 하는 개발자에게는 미리 만들어진 다양한 기능에 대한 테스트 코드가 좋은 참고 자료가 된다.
- 새로운 프레임워크, 기술을 사용할 때 테스트 패키지의 일부로 학습 테스트를 추가한다. 더 나은 사용법이 생기면 학습 테스트의 코드를 수정하여 공유할 수 있다.

### 프레임워크나 제품을 업그레이드할 때 호환성 검증을 도와준다.

- API 등의 제품을 업그레이드할 때 기존 기능에 문제가 없는지 미리 확인할 수 있다.
- 변화가 발생한 경우 그에 맞춰 애플리케이션 코드를 수정할 계획을 세울 수 있다.

### 테스트 작성에 대한 좋은 훈련이 된다.

- 간단한 기능에 초점을 맞춘 학습 테스트로 테스트 작성 훈련을 할 수 있다.
- 간결한 테스트 작성 방법을 연구할 수 있다.

### 새로운 기술을 공부하는 과정이 즐거워진다

- 개발한 코드가 동작하는 것을 봤을 떄의 그 짜릿함을 느낄 수 있고 기억에 오래 남을 것이다.

스프링 학습 테스트를 만들 때 스프링 자신에 대한 테스트 코드를 짜는 것이 가장 좋은 소스이다.

## 버그 테스트

- 버그 테스트(bug test)란 코드에 오류가 있을 때 그 올를 잘 드러내줄 수 있는 테스트를 말한다.
- 버그 테스트는 일단 실패하도록 만들어야 한다. 버그가 원인이 되서 테스트가 실패하는 코드를 만드는 것이다. 그리고 나서 버그 테스트가 성공할 수 있도록 애플리케이션 코드를 수정하여 테스트가 성공하면 버그는 해결된 것이다.

### 테스트의 완성도를 높여준다

- 기존 테스트에서 검증하지 못했던 부분이 있기 때문에 오류가 발생
- 불충분했던 테스트를 보완
- 버그 테스트 덕분에 쉽게 추적이 가능해진다.

### 버그의 내용을 명확하게 분석하게 해준다

- 어떤 이유 때문에 문제가 났는지 효과적으로 파악하고 분석할 수 있다.
- 예외적인 상황이나 입력 값 때문에 발생하는 오류였다면 테스트 코드를 만들면서 오류를 발생시키는 값의 범위가 어떤 것인지 분석해볼 기회가 준다. 테스트의 중요한 기법 중 하나인 동등분할이나 경계값 분석을 적용해볼 수 있다.

### 기술적인 문제를 해결하는데 도움이 된다

- 원인이 무엇인지 정확하게 파악하기 힘들 떄가 있다.
- 기술적으로 다루기 힘든 버그를 발견하는 경우도 있다.
- 동일한 문제가 발생하는 단순한 코드와 그에 대한 버그 테스트를 만들어보면 도움이 된다.

### 동등분할(equivalence partitioning)

- 같은 결과를 내는 값의 범위를 구분해서 각 대표값으로 테스트를 하는 방법
- 어떤 작업의 결과의 종류가 true, false 또는 예외발생 세가지라면 각 결과를 내는 입력 값이나 상황의 조합을 만들어 모든 경우에 대한 테스트 가능

## 경계값 분석(boundary value analysis)

- 에러는 동등분할 범위의 경계에서 주로 많이 발생한다는 특징을 이용해서 경계의 근처에 있는 값을 이용해 테스트하는 방법
- 보통 숫자의 입력값인 경우 0이나 그 주변 값 또는 정수의 최대값, 최소값 드응로 테스트해보면 도움이 된다.

# 6.정리

- 테스트는 자동화돼야 하고 빠르게 실행할 수 있어야 한다.
- `main()` 테스트 대신 JUnit 프레임워크를 이용한 테스트 작성이 편리하다.
- 테스트 결과는 일관성이 있어야 한다. 코드의 변경 없이 환경이나 테스트 실행 수넛에 따라서 결과가 달라지면 안된다.
- 테스트는 포괄적으로 작성해야 한다. 충분한 검증을 하지 않는 테스트는 없는 것보다 나쁠 수 있다.
- 코드 작성과 테스트 수행의 간격이 짧을수록 효과적이다.
- 테스트하기 쉬운 코드가 좋은 코드다.
- 테스트를 먼저 만들고 테스트를 성공시키는 코드를 만들어가는 테스트 주도 개발 방법도 유용하다.
- 테스트 코드도 애플리케이션 코드와 마찬가지로 적절한 리팩토링이 필요하다.
- `@Before`, `@After`를 사용해서 테스트 메소드들의 공통 준비 작업과 정리 작업을 처리할 수 있다.
- 스프링 테스트 컨텍스트 프레임워크를 이용하면 테스트 성능을 향상시킬 수 있다.
- 동일한 설정파일을 사용하는 테스트는 하나의 애플리케이션 컨텍스트를 공유한다.
- `@Autowired`를 사용하면 컨텍스트의 빈을 테스트 오브젝트에 DI 할 수 있다.
- 기술의 사용 방법을 익히고 이해를 돕기 위해 학습 테스트를 작성하자
- 오류가 발견될 경우 그에 대한 버그 테스트를 만들어두면 유용하다.

스프링을 사용하는 개발자라면 자신이 만든 코드를 테스트로 검증하는 방법을 알고 있어야 하며 테스트를 개발에 적극적으로 활용할 수 있어야 한다.
